<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battle Penguins</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background-color: #000;
        }
        canvas {
            display: block;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #4a87ff;
            box-shadow: 0 0 15px rgba(74, 135, 255, 0.7);
            min-width: 220px;
            backdrop-filter: blur(5px);
        }
        .hud-item {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        .hud-icon {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            background-color: #4a87ff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 0 8px rgba(74, 135, 255, 0.8);
        }
        #timer {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            border: 2px solid #ff4a4a;
            box-shadow: 0 0 15px rgba(255, 74, 74, 0.7);
            font-size: 24px;
            font-weight: bold;
            backdrop-filter: blur(5px);
        }
        #ranking {
            position: absolute;
            top: 100px;
            right: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            max-height: 300px;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }
        #ranking h3 {
            margin-top: 0;
            text-align: center;
            color: #ffd700;
            border-bottom: 1px solid #ffd700;
            padding-bottom: 5px;
            font-size: 18px;
        }
        .rank-item {
            margin: 8px 0;
            padding: 5px 8px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            font-size: 14px;
        }
        .rank-first {
            background-color: rgba(255, 215, 0, 0.3);
            border: 1px solid rgba(255, 215, 0, 0.5);
        }
        .rank-player {
            background-color: rgba(74, 135, 255, 0.3);
            border: 1px solid rgba(74, 135, 255, 0.5);
        }
        .rank-icon {
            margin-right: 8px;
            font-size: 16px;
        }
        #powerups {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff4aff;
            box-shadow: 0 0 15px rgba(255, 74, 255, 0.7);
            display: flex;
            gap: 15px;
            backdrop-filter: blur(5px);
        }
        .powerup {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            background-color: rgba(50, 50, 50, 0.7);
            position: relative;
        }
        .powerup-active {
            background-color: rgba(100, 200, 100, 0.7);
            box-shadow: 0 0 10px rgba(100, 255, 100, 0.7);
        }
        .powerup-timer {
            position: absolute;
            bottom: 2px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            border: 3px solid #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            display: none;
            min-width: 350px;
            backdrop-filter: blur(10px);
        }
        #gameOver h2 {
            color: #ffd700;
            margin-top: 0;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        #gameOver button {
            margin-top: 25px;
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        #gameOver button:hover {
            background-color: #45a049;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
        }
        #battleInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            background-color: rgba(255, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
            font-weight: bold;
            display: none;
            backdrop-filter: blur(5px);
        }
        #formationButtons {
            position: absolute;
            bottom: 100px;
            left: 20px;
            display: flex;
            gap: 10px;
            display: none;
        }
        .formation-btn {
            padding: 8px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #4a87ff;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
        }
        .formation-btn:hover, .formation-btn.active {
            background-color: rgba(74, 135, 255, 0.7);
            box-shadow: 0 0 10px rgba(74, 135, 255, 0.7);
        }
    </style>
</head>
<body>
    <div id="hud">
        <div class="hud-item">
            <div class="hud-icon">P</div>
            <div id="playerName">Jogador: PinguimGuerreiro</div>
        </div>
        <div class="hud-item">
            <div class="hud-icon">‚òÖ</div>
            <div id="score">Pontua√ß√£o: 0</div>
        </div>
        <div class="hud-item">
            <div class="hud-icon">‚öîÔ∏è</div>
            <div id="soldierCount">Soldados: 0/25</div>
        </div>
        <div class="hud-item">
            <div class="hud-icon">‚ö°</div>
            <div id="playerSpeed">Velocidade: Normal</div>
        </div>
        <div class="hud-item">
            <div class="hud-icon">üí™</div>
            <div id="playerStrength">For√ßa: Normal</div>
        </div>
    </div>
    <div id="timer">‚è±Ô∏è Tempo: 5:00</div>
    <div id="ranking">
        <h3>üèÜ Ranking</h3>
        <div id="rankingList"></div>
    </div>
    <div id="powerups">
        <div class="powerup" id="speedPowerup">‚ö°<span class="powerup-timer"></span></div>
        <div class="powerup" id="strengthPowerup">üí™<span class="powerup-timer"></span></div>
    </div>
    <div id="battleInfo">‚öîÔ∏è EM BATALHA! ‚öîÔ∏è</div>
    <div id="formationButtons">
        <button class="formation-btn active" id="formationCircle">C√≠rculo</button>
        <button class="formation-btn" id="formationLine">Linha</button>
        <button class="formation-btn" id="formationArrow">Cunha</button>
    </div>
    <div id="gameOver">
        <h2>üéÆ Fim de Jogo!</h2>
        <div id="finalScore"></div>
        <div id="finalRank"></div>
        <button onclick="restartGame()">Jogar Novamente</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Configura√ß√£o inicial
        const GAME_DURATION = 300; // 5 minutos em segundos
        let timeRemaining = GAME_DURATION;
        let gameActive = true;
        
        // Jogadores
        const botNames = ["PinguimAzul", "ImperadorGelo", "FreezeMaster", "ArcticWarrior", "IceTrooper", "FrostyNinja"];
        const playerName = "PinguimGuerreiro";
        
        // Vari√°veis do jogo
        let playerScore = 0;
        let playerSoldiers = [];
        const MAX_SOLDIERS = 25;
        const bots = [];
        const villages = [];
        const BOT_COUNT = 5;
        const trees = [];
        const rocks = [];
        const projectiles = [];
        const powerups = [];
        const battleMarkers = [];
        
        // Forma√ß√£o de batalha atual
        let currentFormation = "circle";
        
        // Power-ups do jogador
        let playerPowerups = {
            speed: {
                active: false,
                multiplier: 1.0,
                duration: 0,
                maxDuration: 30
            },
            strength: {
                active: false,
                multiplier: 1.0,
                duration: 0,
                maxDuration: 30
            }
        };
        
        // Inicializa√ß√£o do Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // C√©u azul claro
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, 10);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        
        // Fog para dar sensa√ß√£o de profundidade
        scene.fog = new THREE.Fog(0x87CEEB, 60, 200);
        
        // Ilumina√ß√£o
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.near = 10;
        directionalLight.shadow.camera.far = 200;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);
        
        // Adicionar ilumina√ß√£o ambiente colorida para mais profundidade
        const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x38761d, 0.3);
        scene.add(hemisphereLight);
        
        // Criar textura de grama
        function createGrassTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            
            // Base verde
            context.fillStyle = '#4CAF50';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Adicionar detalhes de grama
            for (let i = 0; i < 8000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const length = 2 + Math.random() * 4;
                const width = 0.5 + Math.random() * 1.5;
                const angle = Math.random() * Math.PI;
                
                context.save();
                context.translate(x, y);
                context.rotate(angle);
                context.fillStyle = `rgba(${50 + Math.random() * 100}, ${150 + Math.random() * 70}, ${50 + Math.random() * 20}, 0.8)`;
                context.fillRect(-width/2, -length/2, width, length);
                context.restore();
            }
            
            // Adicionar manchas mais escuras/claras
            for (let i = 0; i < 120; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 10 + Math.random() * 40;
                const isDark = Math.random() > 0.5;
                
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                if (isDark) {
                    context.fillStyle = 'rgba(30, 100, 30, 0.3)';
                } else {
                    context.fillStyle = 'rgba(100, 200, 100, 0.3)';
                }
                context.fill();
            }
            
            // Adicionar flores aleat√≥rias
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const radius = 1 + Math.random() * 2;
                
                // Centro da flor
                context.beginPath();
                context.arc(x, y, radius, 0, Math.PI * 2);
                context.fillStyle = `rgba(${200 + Math.random() * 55}, ${200 + Math.random() * 55}, 0, 0.9)`;
                context.fill();
                
                // P√©talas
                const petalCount = 5 + Math.floor(Math.random() * 3);
                const petalSize = radius * (1.5 + Math.random() * 0.5);
                
                for (let j = 0; j < petalCount; j++) {
                    const angle = (j / petalCount) * Math.PI * 2;
                    const petalX = x + Math.cos(angle) * petalSize;
                    const petalY = y + Math.sin(angle) * petalSize;
                    
                    context.beginPath();
                    context.arc(petalX, petalY, radius * 0.8, 0, Math.PI * 2);
                    context.fillStyle = `rgba(${200 + Math.random() * 55}, ${Math.random() * 100}, ${100 + Math.random() * 155}, 0.7)`;
                    context.fill();
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);
            return texture;
        }
        
        // Ch√£o de grama
        const groundGeometry = new THREE.PlaneGeometry(200, 200, 50, 50);
        const grassTexture = createGrassTexture();
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            map: grassTexture,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Adicionar detalhes de altura ao terreno
        const positionAttribute = groundGeometry.getAttribute('position');
        for (let i = 0; i < positionAttribute.count; i++) {
            const x = positionAttribute.getX(i);
            const y = positionAttribute.getY(i);
            const z = positionAttribute.getZ(i);
            
            // Aplicar pequena varia√ß√£o de altura para terreno n√£o ser totalmente plano
            if (Math.abs(x) > 5 || Math.abs(y) > 5) { // Mant√©m o centro plano
                positionAttribute.setZ(i, z + (Math.random() * 0.5 - 0.25));
            }
        }
        groundGeometry.computeVertexNormals();
        
        // Fun√ß√µes para criar elementos do ambiente
        function createTree() {
            const tree = new THREE.Group();
            
            // Tronco
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.8, 4, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1 
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            trunk.castShadow = true;
            tree.add(trunk);
            
            // Detalhes do tronco (n√≥s)
            for (let i = 0; i < 3; i++) {
                const knot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x73482D,
                        roughness: 1.0
                    })
                );
                const angle = Math.random() * Math.PI * 2;
                const height = Math.random() * 3;
                knot.position.set(
                    Math.cos(angle) * 0.5,
                    height + 0.5,
                    Math.sin(angle) * 0.5
                );
                tree.add(knot);
            }
            
            // Copa
            const treeType = Math.floor(Math.random() * 3);
            
            if (treeType === 0) {
                // √Årvore c√¥nica (pinheiro)
                const levels = 2 + Math.floor(Math.random() * 3);
                const baseSize = 4 + Math.random() * 2;
                
                for (let i = 0; i < levels; i++) {
                    const leavesGeometry = new THREE.ConeGeometry(
                        baseSize - i * 0.7, 
                        3, 
                        8
                    );
                    const leavesColor = new THREE.Color(
                        0.1 + Math.random() * 0.1, 
                        0.5 + Math.random() * 0.3, 
                        0.1 + Math.random() * 0.1
                    );
                    const leavesMaterial = new THREE.MeshStandardMaterial({ 
                        color: leavesColor,
                        roughness: 0.8 
                    });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.y = 4 + i * 2;
                    leaves.castShadow = true;
                    tree.add(leaves);
                }
            } else if (treeType === 1) {
                // √Årvore arredondada
                const leavesGeometry = new THREE.SphereGeometry(3 + Math.random(), 10, 10);
                const leavesColor = new THREE.Color(
                    0.1 + Math.random() * 0.1, 
                    0.4 + Math.random() * 0.3, 
                    0.1 + Math.random() * 0.1
                );
                const leavesMaterial = new THREE.MeshStandardMaterial({ 
                    color: leavesColor,
                    roughness: 0.8 
                });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 6;
                leaves.castShadow = true;
                tree.add(leaves);
            } else {
                // √Årvore oval
                const leavesGeometry = new THREE.SphereGeometry(3 + Math.random(), 10, 10);
                leavesGeometry.scale(1, 1.5, 1);
                const leavesColor = new THREE.Color(
                    0.1 + Math.random() * 0.1, 
                    0.4 + Math.random() * 0.3, 
                    0.1 + Math.random() * 0.1
                );
                const leavesMaterial = new THREE.MeshStandardMaterial({ 
                    color: leavesColor,
                    roughness: 0.8 
                });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 6;
                leaves.castShadow = true;
                tree.add(leaves);
            }
            
            return tree;
        }
        
        function createRock() {
            const rockGroup = new THREE.Group();
            
            const segments = 5 + Math.floor(Math.random() * 3);
            const rockGeometry = new THREE.DodecahedronGeometry(
                1 + Math.random() * 1.5, 
                1
            );
            
            // Adicionar alguma varia√ß√£o na forma
            const positionAttribute = rockGeometry.getAttribute('position');
            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                const z = positionAttribute.getZ(i);
                
                const factor = 0.3;
                positionAttribute.setXYZ(
                    i,
                    x * (1 + Math.random() * factor - factor/2),
                    y * (1 + Math.random() * factor - factor/2),
                    z * (1 + Math.random() * factor - factor/2)
                );
            }
            
            // Cor aleat√≥ria em tons de cinza
            const grayValue = 0.3 + Math.random() * 0.4;
            const rockMaterial = new THREE.MeshStandardMaterial({ 
                color: new THREE.Color(grayValue, grayValue, grayValue),
                roughness: 0.9,
                metalness: 0.2
            });
            
            const rock = new THREE.Mesh(rockGeometry, rockMaterial);
            rock.position.y = 0.5;
            rock.castShadow = true;
            rock.receiveShadow = true;
            
            // Aleatorizar rota√ß√£o
            rock.rotation.x = Math.random() * Math.PI;
            rock.rotation.y = Math.random() * Math.PI;
            rock.rotation.z = Math.random() * Math.PI;
            
            rockGroup.add(rock);
            
            // Pequenos detalhes para adicionar textura
            const detailCount = Math.floor(Math.random() * 5) + 3;
            for (let i = 0; i < detailCount; i++) {
                const detailGeo = new THREE.SphereGeometry(0.2 + Math.random() * 0.3, 4, 4);
                const detailMat = new THREE.MeshStandardMaterial({
                    color: new THREE.Color(grayValue * 0.8, grayValue * 0.8, grayValue * 0.8),
                    roughness: 1
                });
                const detail = new THREE.Mesh(detailGeo, detailMat);
                
                // Posicionar na superf√≠cie
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = rock.geometry.parameters.radius * 0.8;
                
                detail.position.set(
                    Math.sin(phi) * Math.cos(theta) * radius,
                    Math.cos(phi) * radius + 0.5,
                    Math.sin(phi) * Math.sin(theta) * radius
                );
                
                detail.castShadow = true;
                rockGroup.add(detail);
            }
            
            return rockGroup;
        }
        
        function createPowerUp(type) {
            const powerup = new THREE.Group();
            
            // Base flutuante
            const baseGeometry = new THREE.CylinderGeometry(1, 1, 0.2, 16);
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.2
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.1;
            base.receiveShadow = true;
            powerup.add(base);
            
            // S√≠mbolo do power-up
            let symbolGeometry, symbolMaterial;
            
            if (type === 'speed') {
                // S√≠mbolo de velocidade (raio)
                symbolGeometry = new THREE.ConeGeometry(0.3, 1.2, 4);
                symbolMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00,
                    emissive: 0xFFFF00,
                    emissiveIntensity: 0.5
                });
                
                const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
                symbol.rotation.z = Math.PI;
                symbol.position.y = 1.2;
                powerup.add(symbol);
                
                // Adicionar detalhes ao raio
                const detail1 = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.2, 0.2),
                    symbolMaterial
                );
                detail1.position.y = 1.4;
                detail1.position.x = 0.2;
                powerup.add(detail1);
                
                const detail2 = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.2, 0.2),
                    symbolMaterial
                );
                detail2.position.y = 0.8;
                detail2.position.x = -0.2;
                powerup.add(detail2);
            } else if (type === 'strength') {
                // S√≠mbolo de for√ßa (bra√ßo musculoso)
                const arm = new THREE.Group();
                
                // Bra√ßo
                const armGeometry = new THREE.CylinderGeometry(0.2, 0.25, 1, 8);
                const armMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.5
                });
                
                const armMesh = new THREE.Mesh(armGeometry, armMaterial);
                armMesh.rotation.z = Math.PI / 4;
                armMesh.position.set(0.2, 0.8, 0);
                arm.add(armMesh);
                
                // M√£o
                const handGeometry = new THREE.SphereGeometry(0.25, 8, 8);
                const handMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.5
                });
                
                const hand = new THREE.Mesh(handGeometry, handMaterial);
                hand.position.set(0.7, 1.2, 0);
                arm.add(hand);
                
                // M√∫sculo (biceps)
                const muscleGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const muscleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.5
                });
                muscleGeometry.scale(1, 0.8, 0.8);
                
                const muscle = new THREE.Mesh(muscleGeometry, muscleMaterial);
                muscle.position.set(0.3, 0.7, 0);
                arm.add(muscle);
                
                powerup.add(arm);
            }
            
            // Efeito de brilho
            const glowGeometry = new THREE.SphereGeometry(1.5, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: type === 'speed' ? 0xFFFF00 : 0xFF0000,
                transparent: true,
                opacity: 0.2
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 1;
            powerup.add(glow);
            
            // Anima√ß√£o
            powerup.userData = {
                type: type,
                floatHeight: 0.5,
                rotationSpeed: 0.01,
                floatSpeed: 0.005,
                floatOffset: Math.random() * Math.PI * 2,
                glowPulse: 0,
                glowMesh: glow
            };
            
            return powerup;
        }
        
        function createBattleMarker() {
            const marker = new THREE.Group();
            
            // C√≠rculo base
            const circleGeometry = new THREE.CircleGeometry(5, 32);
            const circleMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFF0000,
                transparent: true,
                opacity: 0.3
            });
            const circle = new THREE.Mesh(circleGeometry, circleMaterial);
            circle.rotation.x = -Math.PI / 2;
            circle.position.y = 0.05;
            marker.add(circle);
            
            // Espada
            const swordGroup = new THREE.Group();
            
            // L√¢mina
            const bladeGeometry = new THREE.BoxGeometry(0.5, 4, 0.15);
            const bladeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xCCCCCC,
                metalness: 0.8,
                roughness: 0.2
            });
            const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
            blade.position.y = 2;
            swordGroup.add(blade);
            
            // Detalhes da l√¢mina (canal central)
            const bladeDetailGeometry = new THREE.BoxGeometry(0.1, 3.5, 0.2);
            const bladeDetailMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xAAAAAA,
                metalness: 0.9,
                roughness: 0.1
            });
            const bladeDetail = new THREE.Mesh(bladeDetailGeometry, bladeDetailMaterial);
            bladeDetail.position.y = 2;
            swordGroup.add(bladeDetail);
            
            // Ponta da espada
            const tipGeometry = new THREE.ConeGeometry(0.25, 0.8, 4);
            const tip = new THREE.Mesh(tipGeometry, bladeMaterial);
            tip.position.y = 4.4;
            tip.rotation.z = Math.PI;
            swordGroup.add(tip);
            
            // Guarda
            const guardGeometry = new THREE.BoxGeometry(1.5, 0.3, 0.3);
            const guardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8
            });
            const guard = new THREE.Mesh(guardGeometry, guardMaterial);
            guard.position.y = 0;
            swordGroup.add(guard);
            
            // Detalhes da guarda
            const pommelGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const pommelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                metalness: 0.8,
                roughness: 0.2
            });
            const pommel = new THREE.Mesh(pommelGeometry, pommelMaterial);
            pommel.position.y = -1;
            swordGroup.add(pommel);
            
            // Cabo
            const handleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 8);
            const handleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = -0.5;
            swordGroup.add(handle);
            
            // Posicionar espada
            swordGroup.position.y = 8;
            swordGroup.rotation.z = Math.PI / 8;
            marker.add(swordGroup);
            
            // Anima√ß√£o
            marker.userData = {
                rotationSpeed: 0.02,
                pulseSpeed: 0.02,
                pulseAmount: 0.2,
                pulse: 0,
                originalY: 8,
                swordMesh: swordGroup,
                circleMesh: circle
            };
            
            return marker;
        }
        
        // Adicionar √°rvores e pedras
        for (let i = 0; i < 80; i++) {
            const tree = createTree();
            
            // Posicionar as √°rvores aleatoriamente, mas n√£o muito pr√≥ximas umas das outras
            let validPosition = false;
            let attempts = 0;
            let position;
            
            while (!validPosition && attempts < 50) {
                position = new THREE.Vector3(
                    Math.random() * 190 - 95,
                    0,
                    Math.random() * 190 - 95
                );
                
                validPosition = true;
                
                // Verificar dist√¢ncia de outras √°rvores
                for (const otherTree of trees) {
                    if (position.distanceTo(otherTree.position) < 10) {
                        validPosition = false;
                        break;
                    }
                }
                
                attempts++;
            }
            
            if (validPosition) {
                tree.position.copy(position);
                scene.add(tree);
                trees.push(tree);
            }
        }
        
        // Adicionar pedras
        for (let i = 0; i < 60; i++) {
            const rock = createRock();
            
            let validPosition = false;
            let attempts = 0;
            let position;
            
            while (!validPosition && attempts < 50) {
                position = new THREE.Vector3(
                    Math.random() * 190 - 95,
                    0,
                    Math.random() * 190 - 95
                );
                
                validPosition = true;
                
                // Verificar dist√¢ncia de √°rvores e outras pedras
                for (const tree of trees) {
                    if (position.distanceTo(tree.position) < 8) {
                        validPosition = false;
                        break;
                    }
                }
                
                for (const otherRock of rocks) {
                    if (position.distanceTo(otherRock.position) < 5) {
                        validPosition = false;
                        break;
                    }
                }
                
                attempts++;
            }
            
            if (validPosition) {
                rock.position.copy(position);
                scene.add(rock);
                rocks.push(rock);
            }
        }
        
        // Adicionar power-ups
        for (let i = 0; i < 10; i++) {
            const type = Math.random() > 0.5 ? 'speed' : 'strength';
            const powerup = createPowerUp(type);
            
            let validPosition = false;
            let attempts = 0;
            let position;
            
            while (!validPosition && attempts < 50) {
                position = new THREE.Vector3(
                    Math.random() * 180 - 90,
                    0,
                    Math.random() * 180 - 90
                );
                
                validPosition = true;
                
                // Verificar dist√¢ncia de √°rvores, pedras e outros power-ups
                for (const tree of trees) {
                    if (position.distanceTo(tree.position) < 8) {
                        validPosition = false;
                        break;
                    }
                }
                
                for (const rock of rocks) {
                    if (position.distanceTo(rock.position) < 5) {
                        validPosition = false;
                        break;
                    }
                }
                
                for (const otherPowerup of powerups) {
                    if (position.distanceTo(otherPowerup.position) < 15) {
                        validPosition = false;
                        break;
                    }
                }
                
                attempts++;
            }
            
            if (validPosition) {
                powerup.position.copy(position);
                scene.add(powerup);
                powerups.push(powerup);
            }
        }
        
        // Fun√ß√µes para criar modelos 3D
        function createPenguin(isPlayer = false, isLeader = false) {
            const group = new THREE.Group();
            
            // Corpo principal
            const bodyGeometry = new THREE.SphereGeometry(1, 16, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: isPlayer ? 0xFFD700 : 0x000000,
                roughness: 0.7,
                metalness: 0.2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1;
            body.scale.set(1, 1.2, 0.8);
            body.castShadow = true;
            group.add(body);
            
            // Barriga
            const bellyGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const bellyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                roughness: 0.8
            });
            const belly = new THREE.Mesh(bellyGeometry, bellyMaterial);
            belly.position.set(0, 0.9, 0.3);
            belly.scale.y = 1.2;
            group.add(belly);
            
            // Cabe√ßa mais detalhada
            const headGeometry = new THREE.SphereGeometry(0.65, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: isPlayer ? 0xEAC117 : 0x000000,
                roughness: 0.7
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 2.1, 0);
            head.castShadow = true;
            group.add(head);
            
            // Rosto - √°rea branca
            const faceGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            const faceMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const face = new THREE.Mesh(faceGeometry, faceMaterial);
            face.position.set(0, 2.05, 0.3);
            face.scale.set(0.9, 0.9, 0.5);
            group.add(face);
            
            // Bico
            const beakGeometry = new THREE.ConeGeometry(0.2, 0.5, 4);
            const beakMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFA500,
                roughness: 0.6
            });
            const beak = new THREE.Mesh(beakGeometry, beakMaterial);
            beak.position.set(0, 2, 0.8);
            beak.rotation.x = Math.PI / 2;
            group.add(beak);
            
            // Olhos
            const eyeGeometry = new THREE.SphereGeometry(0.15, 12, 12);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.25, 2.2, 0.5);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.25, 2.2, 0.5);
            group.add(rightEye);
            
            // Pupilas
            const pupilGeometry = new THREE.SphereGeometry(0.08, 12, 12);
            const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            leftPupil.position.set(0.25, 2.2, 0.59);
            group.add(leftPupil);
            
            const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            rightPupil.position.set(-0.25, 2.2, 0.59);
            group.add(rightPupil);
            
            // Sobrancelhas
            const eyebrowGeometry = new THREE.BoxGeometry(0.25, 0.05, 0.05);
            const eyebrowMaterial = new THREE.MeshStandardMaterial({ color: isPlayer ? 0xEAC117 : 0x000000 });
            
            const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            leftEyebrow.position.set(0.25, 2.35, 0.5);
            leftEyebrow.rotation.z = Math.PI / 12;
            group.add(leftEyebrow);
            
            const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            rightEyebrow.position.set(-0.25, 2.35, 0.5);
            rightEyebrow.rotation.z = -Math.PI / 12;
            group.add(rightEyebrow);
            
            // P√©s mais detalhados
            const footGeometry = new THREE.BoxGeometry(0.6, 0.2, 0.8);
            footGeometry.translate(0, 0, 0.2); // Deslocar para frente
            const footMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFA500,
                roughness: 0.8
            });
            
            const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
            leftFoot.position.set(0.4, 0.1, 0);
            leftFoot.castShadow = true;
            group.add(leftFoot);
            
            const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
            rightFoot.position.set(-0.4, 0.1, 0);
            rightFoot.castShadow = true;
            group.add(rightFoot);
            
            // Dedos dos p√©s
            const toeGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.2);
            const toeMaterial = new THREE.MeshStandardMaterial({ color: 0xE5901E });
            
            // P√© esquerdo
            for (let i = 0; i < 3; i++) {
                const toe = new THREE.Mesh(toeGeometry, toeMaterial);
                toe.position.set(0.4 - 0.2 + i * 0.2, 0.05, 0.6);
                group.add(toe);
            }
            
            // P√© direito
            for (let i = 0; i < 3; i++) {
                const toe = new THREE.Mesh(toeGeometry, toeMaterial);
                toe.position.set(-0.4 - 0.2 + i * 0.2, 0.05, 0.6);
                group.add(toe);
            }
            
            // Asas
            const wingGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.5);
            wingGeometry.translate(0, -0.3, 0);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: isPlayer ? 0xE6C700 : 0x000000 });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(1, 1.2, 0);
            leftWing.castShadow = true;
            group.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(-1, 1.2, 0);
            rightWing.castShadow = true;
            group.add(rightWing);
            
            // Detalhes do pinguim
            if (isPlayer) {
                // Medalha
                const medalGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16);
                const medalMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFD700,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const medal = new THREE.Mesh(medalGeometry, medalMaterial);
                medal.rotation.x = Math.PI / 2;
                medal.position.set(0, 1.4, 0.8);
                group.add(medal);
                
                // Estrela na medalha
                const starGeometry = new THREE.CircleGeometry(0.15, 5);
                const starMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF0000,
                    metalness: 0.5
                });
                const star = new THREE.Mesh(starGeometry, starMaterial);
                star.position.set(0, 1.4, 0.83);
                star.rotation.x = Math.PI / 2;
                group.add(star);
                
                // Cachecol
                const scarfGeometry = new THREE.BoxGeometry(1.2, 0.3, 1.2);
                scarfGeometry.translate(0, 0, -0.1);
                const scarfMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF0000,
                    roughness: 0.9
                });
                const scarf = new THREE.Mesh(scarfGeometry, scarfMaterial);
                scarf.position.set(0, 1.6, 0);
                group.add(scarf);
                
                // Ponta do cachecol
                const scarfEndGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.1);
                const scarfEnd = new THREE.Mesh(scarfEndGeometry, scarfMaterial);
                scarfEnd.position.set(0.5, 1.3, 0.6);
                scarfEnd.rotation.z = Math.PI / 8;
                group.add(scarfEnd);
                
                // Listras no cachecol
                const stripeGeometry = new THREE.BoxGeometry(1.22, 0.1, 1.22);
                stripeGeometry.translate(0, 0, -0.1);
                const stripeMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.set(0, 1.55, 0);
                group.add(stripe);
            }
            
            // Espa√ßo para a coroa (ser√° adicionada ao vencedor)
            const crownGroup = new THREE.Group();
            crownGroup.position.y = 2.5;
            crownGroup.visible = false; // Escondida inicialmente
            group.add(crownGroup);
            
            // Propriedades de anima√ß√£o
            group.userData = {
                leftWing: leftWing,
                rightWing: rightWing,
                walkTime: 0,
                isWalking: false,
                hasCrown: false,
                leaderCrown: crownGroup
            };
            
            return group;
        }
        
        function createWarrior() {
            const group = new THREE.Group();
            
            // Corpo
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);
            
            // Armadura do peito
            const chestplateGeometry = new THREE.CylinderGeometry(0.32, 0.35, 0.5, 8);
            const chestplateMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xB22222,
                metalness: 0.6,
                roughness: 0.4
            });
            const chestplate = new THREE.Mesh(chestplateGeometry, chestplateMaterial);
            chestplate.position.y = 0.5;
            group.add(chestplate);
            
            // Acabamento met√°lico da armadura
            const trimGeometry = new THREE.TorusGeometry(0.35, 0.03, 8, 16, Math.PI * 2);
            const trimMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.8,
                roughness: 0.2
            });
            const topTrim = new THREE.Mesh(trimGeometry, trimMaterial);
            topTrim.position.y = 0.75;
            topTrim.rotation.x = Math.PI / 2;
            group.add(topTrim);
            
            const bottomTrim = new THREE.Mesh(trimGeometry, trimMaterial);
            bottomTrim.position.y = 0.25;
            bottomTrim.rotation.x = Math.PI / 2;
            group.add(bottomTrim);
            
            // Cabe√ßa
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE4C4 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.2, 0);
            head.castShadow = true;
            group.add(head);
            
            // Rosto
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.1, 1.25, 0.25);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.1, 1.25, 0.25);
            group.add(rightEye);
            
            // Express√£o facial determinada
            const eyebrowGeometry = new THREE.BoxGeometry(0.12, 0.03, 0.03);
            const eyebrowMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            leftEyebrow.position.set(0.1, 1.33, 0.25);
            leftEyebrow.rotation.z = -Math.PI / 8;
            group.add(leftEyebrow);
            
            const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            rightEyebrow.position.set(-0.1, 1.33, 0.25);
            rightEyebrow.rotation.z = Math.PI / 8;
            group.add(rightEyebrow);
            
            // Boca
            const mouthGeometry = new THREE.BoxGeometry(0.1, 0.03, 0.03);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.15, 0.25);
            group.add(mouth);
            
            // Capacete
            const helmetGeometry = new THREE.SphereGeometry(0.35, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const helmetMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xB22222,
                metalness: 0.7,
                roughness: 0.3
            });
            const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
            helmet.position.set(0, 1.2, 0);
            helmet.castShadow = true;
            group.add(helmet);
            
            // Detalhe do capacete
            const helmetCrestGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.05);
            const helmetCrestMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.8
            });
            const helmetCrest = new THREE.Mesh(helmetCrestGeometry, helmetCrestMaterial);
            helmetCrest.position.set(0, 1.55, 0);
            group.add(helmetCrest);
            
            // Protetor nasal do capacete
            const nasalGuardGeometry = new THREE.BoxGeometry(0.05, 0.2, 0.05);
            const nasalGuard = new THREE.Mesh(nasalGuardGeometry, helmetMaterial);
            nasalGuard.position.set(0, 1.2, 0.3);
            group.add(nasalGuard);
            
            // Espada
            const swordGroup = new THREE.Group();
            
            // Cabo da espada mais detalhado
            const swordHandleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.35, 8);
            const swordHandleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9
            });
            const swordHandle = new THREE.Mesh(swordHandleGeometry, swordHandleMaterial);
            swordHandle.castShadow = true;
            swordGroup.add(swordHandle);
            
            // L√¢mina da espada
            const swordBladeGeometry = new THREE.BoxGeometry(0.05, 0.8, 0.01);
            const swordBladeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xC0C0C0,
                metalness: 0.9,
                roughness: 0.1
            });
            const swordBlade = new THREE.Mesh(swordBladeGeometry, swordBladeMaterial);
            swordBlade.position.set(0, 0.55, 0);
            swordBlade.castShadow = true;
            swordGroup.add(swordBlade);
            
            // Canal da espada
            const grooveGeometry = new THREE.BoxGeometry(0.01, 0.7, 0.015);
            const grooveMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xA8A8A8,
                metalness: 0.7
            });
            const groove = new THREE.Mesh(grooveGeometry, grooveMaterial);
            groove.position.set(0, 0.55, 0);
            swordGroup.add(groove);
            
            // Ponta da espada
            const swordTipGeometry = new THREE.ConeGeometry(0.025, 0.15, 8);
            const swordTip = new THREE.Mesh(swordTipGeometry, swordBladeMaterial);
            swordTip.position.set(0, 1.02, 0);
            swordTip.rotation.x = Math.PI;
            swordGroup.add(swordTip);
            
            // Guarda da espada
            const guardGeometry = new THREE.BoxGeometry(0.25, 0.05, 0.08);
            const guardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.8
            });
            const guard = new THREE.Mesh(guardGeometry, guardMaterial);
            guard.position.set(0, 0.15, 0);
            swordGroup.add(guard);
            
            // Pommel (contrapeso)
            const pommelGeometry = new THREE.SphereGeometry(0.04, 8, 8);
            const pommel = new THREE.Mesh(pommelGeometry, guardMaterial);
            pommel.position.set(0, -0.17, 0);
            swordGroup.add(pommel);
            
            swordGroup.position.set(0.5, 0.8, 0);
            swordGroup.rotation.z = Math.PI / 4;
            group.add(swordGroup);
            
            // Escudo
            const shieldGroup = new THREE.Group();
            
            // Forma de escudo mais detalhada
            const shieldShape = new THREE.Shape();
            shieldShape.moveTo(0, 0);
            shieldShape.lineTo(0.25, 0);
            shieldShape.lineTo(0.25, 0.4);
            shieldShape.quadraticCurveTo(0.25, 0.65, 0, 0.7);
            shieldShape.quadraticCurveTo(-0.25, 0.65, -0.25, 0.4);
            shieldShape.lineTo(-0.25, 0);
            shieldShape.lineTo(0, 0);
            
            const shieldGeometry = new THREE.ExtrudeGeometry(shieldShape, {
                steps: 1,
                depth: 0.08,
                bevelEnabled: false
            });
            
            const shieldMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                metalness: 0.6,
                roughness: 0.4
            });
            const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shield.rotation.x = Math.PI / 2;
            shieldGroup.add(shield);
            
            // Emblema no escudo
            const emblemGeometry = new THREE.CircleGeometry(0.15, 16);
            const emblemMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.8,
                roughness: 0.2,
                side: THREE.DoubleSide
            });
            const emblem = new THREE.Mesh(emblemGeometry, emblemMaterial);
            emblem.position.z = 0.04;
            emblem.rotation.x = Math.PI / 2;
            emblem.scale.y = 0.8; // Oval
            shieldGroup.add(emblem);
            
            // Borda met√°lica do escudo
            const shieldBorderShape = new THREE.Shape();
            shieldBorderShape.moveTo(0, 0);
            shieldBorderShape.lineTo(0.27, 0);
            shieldBorderShape.lineTo(0.27, 0.4);
            shieldBorderShape.quadraticCurveTo(0.27, 0.67, 0, 0.73);
            shieldBorderShape.quadraticCurveTo(-0.27, 0.67, -0.27, 0.4);
            shieldBorderShape.lineTo(-0.27, 0);
            shieldBorderShape.lineTo(0, 0);
            
            const borderHole = new THREE.Shape();
            borderHole.moveTo(0, 0.03);
            borderHole.lineTo(0.23, 0.03);
            borderHole.lineTo(0.23, 0.4);
            borderHole.quadraticCurveTo(0.23, 0.63, 0, 0.68);
            borderHole.quadraticCurveTo(-0.23, 0.63, -0.23, 0.4);
            borderHole.lineTo(-0.23, 0.03);
            borderHole.lineTo(0, 0.03);
            
            shieldBorderShape.holes.push(borderHole);
            
            const borderGeometry = new THREE.ExtrudeGeometry(shieldBorderShape, {
                steps: 1,
                depth: 0.09,
                bevelEnabled: false
            });
            
            const borderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.8
            });
            
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.rotation.x = Math.PI / 2;
            shieldGroup.add(border);
            
            shieldGroup.position.set(-0.4, 0.8, 0.1);
            group.add(shieldGroup);
            
            // Ombros
            const shoulderGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const shoulderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                roughness: 0.7
            });
            
            const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            leftShoulder.position.set(0.35, 0.9, 0);
            group.add(leftShoulder);
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            rightShoulder.position.set(-0.35, 0.9, 0);
            group.add(rightShoulder);
            
            // Saia/prote√ß√£o da cintura
            const skirtGeometry = new THREE.CylinderGeometry(0.35, 0.45, 0.3, 8);
            const skirtMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                roughness: 0.6
            });
            const skirt = new THREE.Mesh(skirtGeometry, skirtMaterial);
            skirt.position.y = 0.1;
            group.add(skirt);
            
            // Barra de vida
            const healthBarBg = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.1, 0.05),
                new THREE.MeshBasicMaterial({ color: 0xFF0000 })
            );
            healthBarBg.position.y = 1.8;
            group.add(healthBarBg);
            
            const healthBar = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.1, 0.1),
                new THREE.MeshBasicMaterial({ color: 0x00FF00 })
            );
            healthBar.position.y = 1.8;
            healthBar.position.z = 0.01;
            group.add(healthBar);
            
            // Pernas
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(0.15, 0.25, 0);
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(-0.15, 0.25, 0);
            group.add(rightLeg);
            
            // Botas
            const bootGeometry = new THREE.CylinderGeometry(0.11, 0.13, 0.15, 8);
            const bootMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4B3621,
                roughness: 0.9
            });
            
            const leftBoot = new THREE.Mesh(bootGeometry, bootMaterial);
            leftBoot.position.set(0.15, 0.08, 0);
            group.add(leftBoot);
            
            const rightBoot = new THREE.Mesh(bootGeometry, bootMaterial);
            rightBoot.position.set(-0.15, 0.08, 0);
            group.add(rightBoot);
            
            group.userData = {
                type: 'warrior',
                health: 120,
                maxHealth: 120,
                damage: 25,
                attackSpeed: 1.2,
                attackCooldown: 0,
                healthBar,
                isAttacking: false,
                attackTime: 0,
                sword: swordGroup,
                shield: shieldGroup,
                originalStrength: 25,
                targetPosition: null,
                inFormation: false,
                formationIndex: -1,
                behaviourState: 'follow', // follow, battle, retreat
                battleTarget: null
            };
            
            return group;
        }
        
        function createArcher() {
            const group = new THREE.Group();
            
            // Corpo
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x006400,
                roughness: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);
            
            // T√∫nica de couro
            const tunicGeometry = new THREE.CylinderGeometry(0.32, 0.4, 0.7, 8);
            const tunicMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2E4C0A,
                roughness: 0.9
            });
            const tunic = new THREE.Mesh(tunicGeometry, tunicMaterial);
            tunic.position.y = 0.4;
            group.add(tunic);
            
            // Cintur√£o
            const beltGeometry = new THREE.CylinderGeometry(0.31, 0.31, 0.1, 8);
            const beltMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7
            });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.y = 0.4;
            group.add(belt);
            
            // Fivela
            const buckleGeometry = new THREE.BoxGeometry(0.1, 0.08, 0.12);
            const buckleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.7,
                roughness: 0.3
            });
            const buckle = new THREE.Mesh(buckleGeometry, buckleMaterial);
            buckle.position.set(0, 0.4, 0.3);
            group.add(buckle);
            
            // Cabe√ßa
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE4C4 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.2, 0);
            head.castShadow = true;
            group.add(head);
            
            // Rosto
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.1, 1.25, 0.25);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.1, 1.25, 0.25);
            group.add(rightEye);
            
            // Express√£o concentrada
            const eyebrowGeometry = new THREE.BoxGeometry(0.12, 0.03, 0.03);
            const eyebrowMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            leftEyebrow.position.set(0.1, 1.32, 0.25);
            leftEyebrow.rotation.z = -Math.PI / 12;
            group.add(leftEyebrow);
            
            const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            rightEyebrow.position.set(-0.1, 1.32, 0.25);
            rightEyebrow.rotation.z = Math.PI / 12;
            group.add(rightEyebrow);
            
            // Boca
            const mouthGeometry = new THREE.BoxGeometry(0.07, 0.025, 0.03);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.15, 0.25);
            group.add(mouth);
            
            // Capuz
            const hoodGeometry = new THREE.SphereGeometry(0.35, 16, 16);
            hoodGeometry.scale(1, 0.8, 0.9);
            const hoodMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x228B22,
                roughness: 0.9,
                side: THREE.DoubleSide
            });
            const hood = new THREE.Mesh(hoodGeometry, hoodMaterial);
            hood.position.set(0, 1.3, -0.05);
            hood.scale.set(1, 1.2, 1);
            hood.castShadow = true;
            group.add(hood);
            
            // Ponta do capuz
            const hoodTipGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
            const hoodTip = new THREE.Mesh(hoodTipGeometry, hoodMaterial);
            hoodTip.position.set(0, 1.7, -0.1);
            hoodTip.rotation.x = Math.PI / 4;
            group.add(hoodTip);
            
            // Capa
            const capeGeometry = new THREE.PlaneGeometry(0.8, 1.2);
            const capeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x006400,
                side: THREE.DoubleSide,
                roughness: 0.8
            });
            const cape = new THREE.Mesh(capeGeometry, capeMaterial);
            cape.position.set(0, 0.6, -0.3);
            group.add(cape);
            
            // Arco
            const bowGroup = new THREE.Group();
            
            // Arco (forma mais org√¢nica)
            const bowCurve = new THREE.EllipseCurve(
                0, 0,                 // centro
                0.6, 0.6,             // raio x, raio y
                Math.PI / 2, Math.PI * 1.5, // √¢ngulo inicial e final
                false                 // sentido anti-hor√°rio
            );
            
            const bowPoints = bowCurve.getPoints(20);
            const bowPath = new THREE.CatmullRomCurve3(
                bowPoints.map(p => new THREE.Vector3(p.x, p.y, 0))
            );
            
            const bowGeometry = new THREE.TubeGeometry(bowPath, 20, 0.025, 8, false);
            const bowMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7
            });
            
            const bow = new THREE.Mesh(bowGeometry, bowMaterial);
            bowGroup.add(bow);
            
            // Detalhes do arco
            const bowDetailGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const bowDetailMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.7
            });
            
            // Pontas do arco
            const topDetail = new THREE.Mesh(bowDetailGeometry, bowDetailMaterial);
            topDetail.position.set(0, 0.6, 0);
            bowGroup.add(topDetail);
            
            const bottomDetail = new THREE.Mesh(bowDetailGeometry, bowDetailMaterial);
            bottomDetail.position.set(0, -0.6, 0);
            bowGroup.add(bottomDetail);
            
            // Corda do arco
            const stringGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0.6, 0),
                new THREE.Vector3(0, -0.6, 0)
            ]);
            const stringMaterial = new THREE.LineBasicMaterial({ 
                color: 0xFFFFFF,
                linewidth: 2
            });
            const string = new THREE.Line(stringGeometry, stringMaterial);
            bowGroup.add(string);
            
            // Grip central
            const gripGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.2, 8);
            const gripMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const grip = new THREE.Mesh(gripGeometry, gripMaterial);
            bowGroup.add(grip);
            
            // Binding around grip
            const bindingGeometry = new THREE.TorusGeometry(0.035, 0.01, 8, 12);
            const bindingMaterial = new THREE.MeshStandardMaterial({ color: 0xDDDDDD });
            
            const topBinding = new THREE.Mesh(bindingGeometry, bindingMaterial);
            topBinding.position.y = 0.09;
            topBinding.rotation.x = Math.PI / 2;
            bowGroup.add(topBinding);
            
            const bottomBinding = new THREE.Mesh(bindingGeometry, bindingMaterial);
            bottomBinding.position.y = -0.09;
            bottomBinding.rotation.x = Math.PI / 2;
            bowGroup.add(bottomBinding);
            
            bowGroup.position.set(0.5, 0.8, 0);
            bowGroup.rotation.z = Math.PI / 2;
            group.add(bowGroup);
            
            // Aljava com flechas
            const quiverGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 8);
            const quiverMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8
            });
            const quiver = new THREE.Mesh(quiverGeometry, quiverMaterial);
            quiver.position.set(-0.3, 0.6, 0);
            quiver.rotation.z = Math.PI / 6;
            quiver.castShadow = true;
            group.add(quiver);
            
            // Detalhes na aljava
            const quiverDetailGeometry = new THREE.CylinderGeometry(0.16, 0.16, 0.1, 8);
            const quiverDetailMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xA52A2A,
                roughness: 0.6
            });
            const quiverTop = new THREE.Mesh(quiverDetailGeometry, quiverDetailMaterial);
            quiverTop.position.set(-0.3, 1, 0);
            quiverTop.rotation.z = Math.PI / 6;
            group.add(quiverTop);
            
            // Al√ßa da aljava
            const strapGeometry = new THREE.TorusGeometry(0.1, 0.02, 8, 12, Math.PI);
            const strapMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const strap = new THREE.Mesh(strapGeometry, strapMaterial);
            strap.position.set(-0.3, 0.92, 0.1);
            strap.rotation.x = Math.PI / 2;
            strap.rotation.y = Math.PI / 6;
            group.add(strap);
            
            // Flechas
            for (let i = 0; i < 5; i++) {
                const arrowGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.6, 8);
                const arrowMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D });
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                arrow.position.set(-0.3 + Math.random() * 0.1, 0.8 + i * 0.05, 0);
                arrow.rotation.z = Math.PI / 6;
                arrow.castShadow = true;
                group.add(arrow);
                
                // Ponta da flecha
                const arrowheadGeometry = new THREE.ConeGeometry(0.03, 0.1, 8);
                const arrowheadMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x808080,
                    metalness: 0.8
                });
                const arrowhead = new THREE.Mesh(arrowheadGeometry, arrowheadMaterial);
                arrowhead.position.set(-0.3 + Math.random() * 0.1, 1.1 + i * 0.05, 0);
                arrowhead.rotation.z = Math.PI / 6;
                arrowhead.castShadow = true;
                group.add(arrowhead);
                
                // Penas da flecha
                const featherGeometry = new THREE.BoxGeometry(0.05, 0.02, 0.02);
                const featherMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                const feather = new THREE.Mesh(featherGeometry, featherMaterial);
                feather.position.set(-0.3 + Math.random() * 0.1, 0.6 + i * 0.05, 0);
                feather.rotation.z = Math.PI / 6;
                group.add(feather);
            }
            
            // Pernas
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x3A5F0B });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(0.15, 0.25, 0);
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(-0.15, 0.25, 0);
            group.add(rightLeg);
            
            // Botas
            const bootGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.25);
            const bootMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9
            });
            
            const leftBoot = new THREE.Mesh(bootGeometry, bootMaterial);
            leftBoot.position.set(0.15, 0.05, 0.05);
            group.add(leftBoot);
            
            const rightBoot = new THREE.Mesh(bootGeometry, bootMaterial);
            rightBoot.position.set(-0.15, 0.05, 0.05);
            group.add(rightBoot);
            
            // Barra de vida
            const healthBarBg = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.1, 0.05),
                new THREE.MeshBasicMaterial({ color: 0xFF0000 })
            );
            healthBarBg.position.y = 1.8;
            group.add(healthBarBg);
            
            const healthBar = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.1, 0.1),
                new THREE.MeshBasicMaterial({ color: 0x00FF00 })
            );
            healthBar.position.y = 1.8;
            healthBar.position.z = 0.01;
            group.add(healthBar);
            
            group.userData = {
                type: 'archer',
                health: 80,
                maxHealth: 80,
                damage: 18,
                attackSpeed: 1.5,
                attackCooldown: 0,
                range: 8,
                healthBar,
                bow: bowGroup,
                isAttacking: false,
                attackTime: 0,
                originalStrength: 18,
                targetPosition: null,
                inFormation: false,
                formationIndex: -1,
                behaviourState: 'follow', // follow, battle, retreat
                battleTarget: null
            };
            
            return group;
        }
        
        function createMage() {
            const group = new THREE.Group();
            
            // Corpo
            const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4B0082,
                roughness: 0.7
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);
            
            // Manto/t√∫nica com detalhes
            const robeGeometry = new THREE.CylinderGeometry(0.32, 0.5, 1.1, 8);
            const robeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x663399,
                roughness: 0.8
            });
            const robe = new THREE.Mesh(robeGeometry, robeMaterial);
            robe.position.y = 0.45;
            group.add(robe);
            
            // Padr√µes arcanos na t√∫nica
            const patternGroup = new THREE.Group();
            
            // S√≠mbolos arcanos (estrelas, espirais, etc)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const symbolSize = 0.06 + Math.random() * 0.04;
                
                const symbolGeometry = new THREE.CircleGeometry(symbolSize, 5);
                const symbolMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00FFFF,
                    emissive: 0x00FFFF,
                    emissiveIntensity: 0.3,
                    side: THREE.DoubleSide
                });
                
                const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
                symbol.position.set(
                    Math.cos(angle) * 0.3,
                    0.4 + Math.random() * 0.6,
                    Math.sin(angle) * 0.3 + 0.1
                );
                symbol.rotation.x = Math.PI / 2;
                symbol.rotation.y = Math.random() * Math.PI;
                
                patternGroup.add(symbol);
            }
            
            group.add(patternGroup);
            
            // Cabe√ßa
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE4C4 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 1.2, 0);
            head.castShadow = true;
            group.add(head);
            
            // Rosto com express√£o m√≠stica
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00FFFF,
                emissive: 0x00FFFF,
                emissiveIntensity: 0.5
            });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.1, 1.25, 0.25);
            leftEye.scale.x = 1.2;
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.1, 1.25, 0.25);
            rightEye.scale.x = 1.2;
            group.add(rightEye);
            
            // Sobrancelhas arqueadas
            const eyebrowGeometry = new THREE.BoxGeometry(0.15, 0.03, 0.03);
            const eyebrowMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            
            const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            leftEyebrow.position.set(0.1, 1.35, 0.25);
            leftEyebrow.rotation.z = -Math.PI / 6;
            group.add(leftEyebrow);
            
            const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            rightEyebrow.position.set(-0.1, 1.35, 0.25);
            rightEyebrow.rotation.z = Math.PI / 6;
            group.add(rightEyebrow);
            
            // Boca
            const mouthGeometry = new THREE.BoxGeometry(0.1, 0.025, 0.03);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.12, 0.25);
            group.add(mouth);
            
            // Barba detalhada
            const beardGroup = new THREE.Group();
            
            // Base da barba
            const beardBaseGeometry = new THREE.ConeGeometry(0.25, 0.4, 8);
            beardBaseGeometry.translate(0, -0.2, 0);
            const beardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                roughness: 1.0
            });
            
            const beardBase = new THREE.Mesh(beardBaseGeometry, beardMaterial);
            beardBase.position.set(0, 1.1, 0.2);
            beardGroup.add(beardBase);
            
            // Detalhes na barba (mechas)
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI;
                const strandGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.3, 4);
                const strand = new THREE.Mesh(strandGeometry, beardMaterial);
                
                strand.position.set(
                    Math.cos(angle) * 0.15,
                    0.9 - Math.random() * 0.1,
                    Math.sin(angle) * 0.15 + 0.2
                );
                
                strand.rotation.x = Math.PI / 6;
                strand.rotation.y = angle;
                beardGroup.add(strand);
            }
            
            group.add(beardGroup);
            
            // Chap√©u de mago mais detalhado
            const hatGroup = new THREE.Group();
            
            const hatBaseGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.1, 16);
            const hatMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4B0082,
                roughness: 0.8
            });
            const hatBase = new THREE.Mesh(hatBaseGeometry, hatMaterial);
            hatGroup.add(hatBase);
            
            // Cone
            const hatTopGeometry = new THREE.ConeGeometry(0.35, 0.9, 16);
            const hatTopMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4B0082,
                roughness: 0.7
            });
            const hatTop = new THREE.Mesh(hatTopGeometry, hatTopMaterial);
            hatTop.position.y = 0.5;
            hatGroup.add(hatTop);
            
            // Borda do chap√©u
            const hatRimGeometry = new THREE.TorusGeometry(0.45, 0.05, 8, 24);
            const hatRimMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x663399,
                roughness: 0.6
            });
            const hatRim = new THREE.Mesh(hatRimGeometry, hatRimMaterial);
            hatRim.position.y = 0;
            hatRim.rotation.x = Math.PI / 2;
            hatGroup.add(hatRim);
            
            // Detalhes no chap√©u
            const hatBandGeometry = new THREE.CylinderGeometry(0.36, 0.36, 0.12, 16);
            const hatBandMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.6,
                roughness: 0.4
            });
            const hatBand = new THREE.Mesh(hatBandGeometry, hatBandMaterial);
            hatBand.position.y = 0.15;
            hatGroup.add(hatBand);
            
            // Adicionar estrelas ao chap√©u
            for (let i = 0; i < 5; i++) {
                const starGeometry = new THREE.CircleGeometry(0.05, 5);
                const starMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFF00,
                    emissive: 0xFFFF00,
                    emissiveIntensity: 0.5,
                    side: THREE.DoubleSide
                });
                
                const star = new THREE.Mesh(starGeometry, starMaterial);
                const angle = (i / 5) * Math.PI * 2;
                const height = Math.random() * 0.6;
                
                star.position.set(
                    Math.cos(angle) * (0.35 - height * 0.2),
                    height,
                    Math.sin(angle) * (0.35 - height * 0.2)
                );
                
                // Rotacionar a estrela para ficar perpendicular √† superf√≠cie do cone
                star.lookAt(new THREE.Vector3(
                    Math.cos(angle) * 2,
                    height,
                    Math.sin(angle) * 2
                ));
                
                hatGroup.add(star);
            }
            
            // Curva na ponta do chap√©u
            const hatTipGeometry = new THREE.TorusGeometry(0.1, 0.03, 8, 16, Math.PI);
            const hatTip = new THREE.Mesh(hatTipGeometry, hatMaterial);
            hatTip.position.y = 0.95;
            hatTip.rotation.x = -Math.PI / 2;
            hatTip.rotation.z = Math.PI / 2;
            hatGroup.add(hatTip);
            
            // Esfera na ponta
            const tipSphereGeometry = new THREE.SphereGeometry(0.06, 8, 8);
            const tipSphereMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFF00,
                emissive: 0xFFFF00,
                emissiveIntensity: 0.3
            });
            const tipSphere = new THREE.Mesh(tipSphereGeometry, tipSphereMaterial);
            tipSphere.position.set(0.1, 0.95, 0);
            hatGroup.add(tipSphere);
            
            hatGroup.position.y = 1.5;
            group.add(hatGroup);
            
            // Cajado
            const staffGroup = new THREE.Group();
            
            // Haste
            const staffGeometry = new THREE.CylinderGeometry(0.03, 0.04, 1.8, 8);
            const staffMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7
            });
            const staff = new THREE.Mesh(staffGeometry, staffMaterial);
            staff.position.y = 0.7;
            staffGroup.add(staff);
            
            // Detalhes do cajado (an√©is met√°licos)
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.TorusGeometry(0.04, 0.01, 8, 16);
                const ringMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xD4AF37,
                    metalness: 0.8
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.y = 0.3 + i * 0.5;
                ring.rotation.x = Math.PI / 2;
                staffGroup.add(ring);
            }
            
            // Orbe no topo do cajado com decora√ß√µes
            const orbeGeometry = new THREE.SphereGeometry(0.18, 16, 16);
            const orbeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00FFFF,
                emissive: 0x00FFFF,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.8
            });
            const orbe = new THREE.Mesh(orbeGeometry, orbeMaterial);
            orbe.position.y = 1.6;
            staffGroup.add(orbe);
            
            // An√©is de energia em volta do orbe
            const energyRingGeometry = new THREE.TorusGeometry(0.25, 0.02, 8, 24);
            const energyRingMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.5
            });
            
            const energyRing1 = new THREE.Mesh(energyRingGeometry, energyRingMaterial);
            energyRing1.position.y = 1.6;
            energyRing1.rotation.x = Math.PI / 2;
            staffGroup.add(energyRing1);
            
            const energyRing2 = new THREE.Mesh(energyRingGeometry, energyRingMaterial);
            energyRing2.position.y = 1.6;
            energyRing2.rotation.x = Math.PI / 3;
            energyRing2.rotation.y = Math.PI / 4;
            staffGroup.add(energyRing2);
            
            // Base do orbe
            const orbeBaseGeometry = new THREE.CylinderGeometry(0.06, 0.04, 0.15, 8);
            const orbeBaseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.7
            });
            const orbeBase = new THREE.Mesh(orbeBaseGeometry, orbeBaseMaterial);
            orbeBase.position.y = 1.43;
            staffGroup.add(orbeBase);
            
            // Garras segurando o orbe
            const clawCount = 4;
            for (let i = 0; i < clawCount; i++) {
                const angle = (i / clawCount) * Math.PI * 2;
                
                const clawGeometry = new THREE.CylinderGeometry(0.01, 0.02, 0.3, 4);
                clawGeometry.translate(0, 0.15, 0);
                const clawMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xD4AF37,
                    metalness: 0.7
                });
                
                const claw = new THREE.Mesh(clawGeometry, clawMaterial);
                claw.position.set(
                    Math.cos(angle) * 0.05,
                    1.43,
                    Math.sin(angle) * 0.05
                );
                
                claw.rotation.x = Math.PI / 4;
                claw.rotation.y = angle;
                staffGroup.add(claw);
            }
            
            // Efeito de brilho no orbe
            const glowGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = 1.6;
            staffGroup.add(glow);
            
            staffGroup.position.set(0.5, 0.0, 0);
            staffGroup.rotation.z = Math.PI / 12;
            group.add(staffGroup);
            
            // Borda da t√∫nica
            const robeHemGeometry = new THREE.CylinderGeometry(0.52, 0.52, 0.1, 8);
            const robeHemMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.5,
                roughness: 0.5
            });
            const robeHem = new THREE.Mesh(robeHemGeometry, robeHemMaterial);
            robeHem.position.y = -0.05;
            group.add(robeHem);
            
            // Adere√ßos nas mangas
            const sleeveDetailGeometry = new THREE.CylinderGeometry(0.1, 0.08, 0.15, 8);
            const sleeveDetailMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.5,
                roughness: 0.5
            });
            
            const leftSleeveDetail = new THREE.Mesh(sleeveDetailGeometry, sleeveDetailMaterial);
            leftSleeveDetail.position.set(0.32, 0.8, 0);
            leftSleeveDetail.rotation.z = Math.PI / 2;
            group.add(leftSleeveDetail);
            
            const rightSleeveDetail = new THREE.Mesh(sleeveDetailGeometry, sleeveDetailMaterial);
            rightSleeveDetail.position.set(-0.32, 0.8, 0);
            rightSleeveDetail.rotation.z = -Math.PI / 2;
            group.add(rightSleeveDetail);
            
            // Barra de vida
            const healthBarBg = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.1, 0.05),
                new THREE.MeshBasicMaterial({ color: 0xFF0000 })
            );
            healthBarBg.position.y = 2.3;
            group.add(healthBarBg);
            
            const healthBar = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 0.1, 0.1),
                new THREE.MeshBasicMaterial({ color: 0x00FF00 })
            );
            healthBar.position.y = 2.3;
            healthBar.position.z = 0.01;
            group.add(healthBar);
            
            group.userData = {
                type: 'mage',
                health: 60,
                maxHealth: 60,
                damage: 30,
                attackSpeed: 1.0,
                attackCooldown: 0,
                range: 10,
                healthBar,
                staff: staffGroup,
                orbe: orbe,
                glow: glow,
                energyRing1: energyRing1,
                energyRing2: energyRing2,
                isAttacking: false,
                attackTime: 0,
                originalStrength: 30,
                targetPosition: null,
                inFormation: false,
                formationIndex: -1,
                behaviourState: 'follow', // follow, battle, retreat
                battleTarget: null
            };
            
            return group;
        }
        
        function createGiant() {
            const group = new THREE.Group();
            
            // Corpo principal (maior)
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1.8, 10);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.9;
            body.scale.set(1.5, 1, 1.5);
            body.castShadow = true;
            group.add(body);
            
            // Armadura de peitoral
            const chestplateGeometry = new THREE.CylinderGeometry(0.8, 0.7, 0.9, 8);
            const chestplateMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x696969,
                metalness: 0.6,
                roughness: 0.5
            });
            const chestplate = new THREE.Mesh(chestplateGeometry, chestplateMaterial);
            chestplate.position.y = 1.1;
            group.add(chestplate);
            
            // Rebites/pregos na armadura
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const rivetGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.1, 8);
                const rivetMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x333333,
                    metalness: 0.9,
                    roughness: 0.2
                });
                
                const rivet = new THREE.Mesh(rivetGeometry, rivetMaterial);
                rivet.position.set(
                    Math.cos(angle) * 0.7,
                    1.1,
                    Math.sin(angle) * 0.7
                );
                
                rivet.rotation.x = Math.PI / 2;
                rivet.rotation.y = angle;
                group.add(rivet);
            }
            
            // Cabe√ßa
            const headGeometry = new THREE.SphereGeometry(0.45, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFE4C4,
                roughness: 0.8
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 2.1, 0);
            head.castShadow = true;
            group.add(head);
            
            // Rosto com express√£o feroz
            const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFF4500 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(0.15, 2.2, 0.35);
            group.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(-0.15, 2.2, 0.35);
            group.add(rightEye);
            
            // Sobrancelhas grossas e anguladas
            const eyebrowGeometry = new THREE.BoxGeometry(0.3, 0.08, 0.05);
            const eyebrowMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            
            const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            leftEyebrow.position.set(0.15, 2.35, 0.35);
            leftEyebrow.rotation.z = Math.PI / 12;
            leftEyebrow.rotation.y = -Math.PI / 24;
            group.add(leftEyebrow);
            
            const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            rightEyebrow.position.set(-0.15, 2.35, 0.35);
            rightEyebrow.rotation.z = -Math.PI / 12;
            rightEyebrow.rotation.y = Math.PI / 24;
            group.add(rightEyebrow);
            
            // Nariz grande
            const noseGeometry = new THREE.BoxGeometry(0.12, 0.2, 0.12);
            const noseMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD39B });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 2.15, 0.45);
            group.add(nose);
            
            // Boca com dentes
            const mouthGeometry = new THREE.BoxGeometry(0.25, 0.06, 0.05);
            const mouthMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 1.95, 0.4);
            mouth.rotation.x = Math.PI / 16;
            group.add(mouth);
            
            // Dentes
            const teethGeometry = new THREE.BoxGeometry(0.04, 0.04, 0.02);
            const teethMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            
            for (let i = 0; i < 3; i++) {
                const tooth = new THREE.Mesh(teethGeometry, teethMaterial);
                tooth.position.set(-0.1 + i * 0.1, 1.93, 0.43);
                group.add(tooth);
            }
            
            // Barba rala
            const beardGeometry = new THREE.BoxGeometry(0.4, 0.15, 0.2);
            const beardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 1.0,
                transparent: true,
                opacity: 0.7
            });
            const beard = new THREE.Mesh(beardGeometry, beardMaterial);
            beard.position.set(0, 1.85, 0.3);
            group.add(beard);
            
            // Capacete viking mais detalhado
            const helmetBaseGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.35, 8);
            const helmetMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                metalness: 0.5,
                roughness: 0.5
            });
            const helmetBase = new THREE.Mesh(helmetBaseGeometry, helmetMaterial);
            helmetBase.position.set(0, 2.25, 0);
            group.add(helmetBase);
            
            // Protetor nasal
            const nasalGeometry = new THREE.BoxGeometry(0.08, 0.3, 0.08);
            const nasalGuard = new THREE.Mesh(nasalGeometry, helmetMaterial);
            nasalGuard.position.set(0, 2.15, 0.3);
            group.add(nasalGuard);
            
            // Rebites no capacete
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const rivetGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.08, 8);
                const rivetMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x696969,
                    metalness: 0.8
                });
                
                const rivet = new THREE.Mesh(rivetGeometry, rivetMaterial);
                rivet.position.set(
                    Math.cos(angle) * 0.45,
                    2.25,
                    Math.sin(angle) * 0.45
                );
                
                rivet.rotation.x = Math.PI / 2;
                rivet.rotation.y = angle;
                group.add(rivet);
            }
            
            // Chifres do capacete estilizados
            const leftHornGroup = new THREE.Group();
            const rightHornGroup = new THREE.Group();
            
            function createHorn() {
                const hornGroup = new THREE.Group();
                
                // Segmentos de chifre curvados
                const segments = 5;
                const curveFactor = 0.15;
                
                for (let i = 0; i < segments; i++) {
                    const segRadius = 0.08 - (i * 0.01);
                    const segHeight = 0.2;
                    
                    const segGeometry = new THREE.CylinderGeometry(
                        segRadius * 0.8, 
                        segRadius, 
                        segHeight, 
                        8
                    );
                    
                    const segMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xD2B48C,
                        roughness: 0.9
                    });
                    
                    const segment = new THREE.Mesh(segGeometry, segMaterial);
                    segment.position.y = i * segHeight;
                    
                    // Curvar cada segmento
                    segment.rotation.x = curveFactor * i;
                    
                    hornGroup.add(segment);
                }
                
                return hornGroup;
            }
            
            const leftHorn = createHorn();
            leftHorn.position.set(0, 0, 0);
            leftHorn.rotation.x = Math.PI / 6;
            leftHornGroup.add(leftHorn);
            
            const rightHorn = createHorn();
            rightHorn.position.set(0, 0, 0);
            rightHorn.rotation.x = Math.PI / 6;
            rightHornGroup.add(rightHorn);
            
            leftHornGroup.position.set(0.4, 2.2, 0);
            leftHornGroup.rotation.z = Math.PI / 4;
            group.add(leftHornGroup);
            
            rightHornGroup.position.set(-0.4, 2.2, 0);
            rightHornGroup.rotation.z = -Math.PI / 4;
            group.add(rightHornGroup);
            
            // Ombros com placas
            const shoulderGeometry = new THREE.SphereGeometry(0.45, 10, 10);
            shoulderGeometry.scale(1, 0.7, 1);
            const shoulderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x696969,
                metalness: 0.6,
                roughness: 0.5
            });
            
            const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            leftShoulder.position.set(0.8, 1.6, 0);
            group.add(leftShoulder);
            
            const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
            rightShoulder.position.set(-0.8, 1.6, 0);
            group.add(rightShoulder);
            
            // Espinhos nas placas dos ombros
            for (let i = 0; i < 3; i++) {
                const spikeGeometry = new THREE.ConeGeometry(0.07, 0.2, 4);
                const spikeMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B0000,
                    metalness: 0.4
                });
                
                const leftSpike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                leftSpike.position.set(
                    0.8,
                    1.6 + 0.3,
                    -0.2 + i * 0.2
                );
                leftSpike.rotation.x = -Math.PI / 2;
                group.add(leftSpike);
                
                const rightSpike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                rightSpike.position.set(
                    -0.8,
                    1.6 + 0.3,
                    -0.2 + i * 0.2
                );
                rightSpike.rotation.x = -Math.PI / 2;
                group.add(rightSpike);
            }
            
            // Bra√ßos musculosos com detalhes de pele
            const armGeometry = new THREE.CylinderGeometry(0.25, 0.2, 0.9, 8);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE4C4 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(0.8, 1.15, 0);
            leftArm.rotation.z = Math.PI / 8;
            group.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(-0.8, 1.15, 0);
            rightArm.rotation.z = -Math.PI / 8;
            group.add(rightArm);
            
            // Veias/m√∫sculos nos bra√ßos
            const veinGeometry = new THREE.BoxGeometry(0.05, 0.4, 0.05);
            veinGeometry.translate(0, 0, 0.15);
            const veinMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xE6C3A1,
                roughness: 0.9
            });
            
            const leftVein = new THREE.Mesh(veinGeometry, veinMaterial);
            leftVein.position.copy(leftArm.position);
            leftVein.rotation.z = Math.PI / 8;
            group.add(leftVein);
            
            const rightVein = new THREE.Mesh(veinGeometry, veinMaterial);
            rightVein.position.copy(rightArm.position);
            rightVein.rotation.z = -Math.PI / 8;
            group.add(rightVein);
            
            // M√∫sculos nos bra√ßos (detalhes)
            const muscleGeometry = new THREE.SphereGeometry(0.28, 8, 8);
            muscleGeometry.scale(1, 0.6, 1);
            const muscleMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE4C4 });
            
            const leftMuscle = new THREE.Mesh(muscleGeometry, muscleMaterial);
            leftMuscle.position.set(0.8, 1.3, 0);
            group.add(leftMuscle);
            
            const rightMuscle = new THREE.Mesh(muscleGeometry, muscleMaterial);
            rightMuscle.position.set(-0.8, 1.3, 0);
            group.add(rightMuscle);
            
            // Braceletes
            const braceletGeometry = new THREE.CylinderGeometry(0.22, 0.22, 0.1, 8);
            const braceletMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                metalness: 0.4
            });
            
            const leftBracelet = new THREE.Mesh(braceletGeometry, braceletMaterial);
            leftBracelet.position.set(0.85, 0.9, 0);
            leftBracelet.rotation.z = Math.PI / 8;
            group.add(leftBracelet);
            
            const rightBracelet = new THREE.Mesh(braceletGeometry, braceletMaterial);
            rightBracelet.position.set(-0.85, 0.9, 0);
            rightBracelet.rotation.z = -Math.PI / 8;
            group.add(rightBracelet);
            
            // M√£os enormes
            const handGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.4);
            const handMaterial = new THREE.MeshStandardMaterial({ color: 0xFFE4C4 });
            
            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(0.9, 0.7, 0);
            leftHand.rotation.z = Math.PI / 8;
            group.add(leftHand);
            
            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(-0.9, 0.7, 0);
            rightHand.rotation.z = -Math.PI / 8;
            group.add(rightHand);
            
            // Grande martelo com mais detalhes
            const hammerGroup = new THREE.Group();
            
            // Cabo do martelo
            const handleGeometry = new THREE.CylinderGeometry(0.08, 0.1, 2, 8);
            const handleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.y = -0.2;
            hammerGroup.add(handle);
            
            // Refor√ßo met√°lico no cabo
            const reinforceGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.15, 8);
            const reinforceMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x696969,
                metalness: 0.7
            });
            
            const topReinforce = new THREE.Mesh(reinforceGeometry, reinforceMaterial);
            topReinforce.position.y = 0.8;
            hammerGroup.add(topReinforce);
            
            const bottomReinforce = new THREE.Mesh(reinforceGeometry, reinforceMaterial);
            bottomReinforce.position.y = -1.2;
            hammerGroup.add(bottomReinforce);
            
            // Cabe√ßa do martelo estilizada
            const hammerHeadGroup = new THREE.Group();
            
            // Base da cabe√ßa
            const headBaseGeometry = new THREE.BoxGeometry(0.2, 0.5, 0.3);
            const headBaseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x696969,
                metalness: 0.8,
                roughness: 0.3
            });
            const headBase = new THREE.Mesh(headBaseGeometry, headBaseMaterial);
            hammerHeadGroup.add(headBase);
            
            // Martelo principal
            const hammerHeadGeometry = new THREE.BoxGeometry(0.7, 0.4, 0.5);
            const hammerHeadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                metalness: 0.8,
                roughness: 0.2
            });
            const hammerHead = new THREE.Mesh(hammerHeadGeometry, hammerHeadMaterial);
            hammerHeadGroup.add(hammerHead);
            
            // Espig√£o traseiro
            const spikeGeometry = new THREE.ConeGeometry(0.15, 0.4, 4);
            const spikeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x696969,
                metalness: 0.8
            });
            const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
            spike.position.x = -0.5;
            spike.rotation.z = -Math.PI / 2;
            hammerHeadGroup.add(spike);
            
            // Detalhes na cabe√ßa do martelo
            const detailGeometry = new THREE.BoxGeometry(0.75, 0.05, 0.55);
            const detailMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xA52A2A
            });
            
            const topDetail = new THREE.Mesh(detailGeometry, detailMaterial);
            topDetail.position.y = 0.22;
            hammerHeadGroup.add(topDetail);
            
            const bottomDetail = new THREE.Mesh(detailGeometry, detailMaterial);
            bottomDetail.position.y = -0.22;
            hammerHeadGroup.add(bottomDetail);
            
            // Runas gravadas
            const runePlaneGeometry = new THREE.PlaneGeometry(0.5, 0.2);
            const runeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                emissive: 0xD4AF37,
                emissiveIntensity: 0.2,
                side: THREE.DoubleSide
            });
            
            const frontRune = new THREE.Mesh(runePlaneGeometry, runeMaterial);
            frontRune.position.z = 0.251;
            hammerHeadGroup.add(frontRune);
            
            const backRune = new THREE.Mesh(runePlaneGeometry, runeMaterial);
            backRune.position.z = -0.251;
            backRune.rotation.y = Math.PI;
            hammerHeadGroup.add(backRune);
            
            // Posicionar cabe√ßa do martelo
            hammerHeadGroup.position.y = 0.9;
            hammerGroup.add(hammerHeadGroup);
            
            // Adicionar corrente ao martelo
            const chainGroup = new THREE.Group();
            
            for (let i = 0; i < 5; i++) {
                const linkGeometry = new THREE.TorusGeometry(0.06, 0.02, 8, 16);
                const linkMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x696969,
                    metalness: 0.7
                });
                
                const link = new THREE.Mesh(linkGeometry, linkMaterial);
                link.position.y = -1.2 - i * 0.1;
                link.rotation.x = (i % 2) * Math.PI / 2;
                chainGroup.add(link);
            }
            
            hammerGroup.add(chainGroup);
            
            // Posicionar martelo
            hammerGroup.position.set(1.1, 1.2, 0);
            hammerGroup.rotation.z = Math.PI / 3;
            group.add(hammerGroup);
            
            // Pernas robustas
            const legGeometry = new THREE.CylinderGeometry(0.25, 0.23, 0.9, 8);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.8
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(0.3, 0.45, 0);
            group.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(-0.3, 0.45, 0);
            group.add(rightLeg);
            
            // Prote√ß√µes nas canelas
            const shinGuardGeometry = new THREE.CylinderGeometry(0.27, 0.25, 0.5, 8);
            const shinGuardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                metalness: 0.4
            });
            
            const leftShinGuard = new THREE.Mesh(shinGuardGeometry, shinGuardMaterial);
            leftShinGuard.position.set(0.3, 0.3, 0);
            group.add(leftShinGuard);
            
            const rightShinGuard = new THREE.Mesh(shinGuardGeometry, shinGuardMaterial);
            rightShinGuard.position.set(-0.3, 0.3, 0);
            group.add(rightShinGuard);
            
            // Botas
            const bootGeometry = new THREE.BoxGeometry(0.35, 0.25, 0.5);
            const bootMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9
            });
            
            const leftBoot = new THREE.Mesh(bootGeometry, bootMaterial);
            leftBoot.position.set(0.3, 0.12, 0.1);
            group.add(leftBoot);
            
            const rightBoot = new THREE.Mesh(bootGeometry, bootMaterial);
            rightBoot.position.set(-0.3, 0.12, 0.1);
            group.add(rightBoot);
            
            // Pontas de metal nas botas
            const bootTipGeometry = new THREE.ConeGeometry(0.1, 0.2, 4);
            bootTipGeometry.rotateX(-Math.PI / 2);
            const bootTipMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x696969,
                metalness: 0.7
            });
            
            const leftBootTip = new THREE.Mesh(bootTipGeometry, bootTipMaterial);
            leftBootTip.position.set(0.3, 0.12, 0.35);
            group.add(leftBootTip);
            
            const rightBootTip = new THREE.Mesh(bootTipGeometry, bootTipMaterial);
            rightBootTip.position.set(-0.3, 0.12, 0.35);
            group.add(rightBootTip);
            
            // Saia de prote√ß√£o (kilt)
            const kiltGeometry = new THREE.CylinderGeometry(0.75, 0.9, 0.4, 8);
            const kiltMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B0000,
                roughness: 0.7
            });
            const kilt = new THREE.Mesh(kiltGeometry, kiltMaterial);
            kilt.position.y = 0.7;
            group.add(kilt);
            
            // Detalhes no kilt (placas met√°licas)
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const plateGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.05);
                const plateMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x696969,
                    metalness: 0.6
                });
                
                const plate = new THREE.Mesh(plateGeometry, plateMaterial);
                plate.position.set(
                    Math.cos(angle) * 0.77,
                    0.7,
                    Math.sin(angle) * 0.77
                );
                
                plate.rotation.y = angle;
                group.add(plate);
            }
            
            // Cinto
            const beltGeometry = new THREE.CylinderGeometry(0.76, 0.76, 0.15, 8);
            const beltMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.7
            });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.y = 0.9;
            group.add(belt);
            
            // Fivela
            const buckleGeometry = new THREE.BoxGeometry(0.2, 0.12, 0.1);
            const buckleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xD4AF37,
                metalness: 0.7
            });
            const buckle = new THREE.Mesh(buckleGeometry, buckleMaterial);
            buckle.position.set(0, 0.9, 0.75);
            group.add(buckle);
            
            // Barra de vida
            const healthBarBg = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.12, 0.05),
                new THREE.MeshBasicMaterial({ color: 0xFF0000 })
            );
            healthBarBg.position.y = 2.8;
            group.add(healthBarBg);
            
            const healthBar = new THREE.Mesh(
                new THREE.BoxGeometry(1, 0.12, 0.1),
                new THREE.MeshBasicMaterial({ color: 0x00FF00 })
            );
            healthBar.position.y = 2.8;
            healthBar.position.z = 0.01;
            group.add(healthBar);
            
            group.userData = {
                type: 'giant',
                health: 200,
                maxHealth: 200,
                damage: 40,
                attackSpeed: 0.7,
                attackCooldown: 0,
                healthBar,
                hammer: hammerGroup,
                isAttacking: false,
                attackTime: 0,
                originalStrength: 40,
                targetPosition: null,
                inFormation: false,
                formationIndex: -1,
                behaviourState: 'follow', // follow, battle, retreat
                battleTarget: null
            };
            
            return group;
        }
        
        function createArrow(startPosition, direction, owner) {
            const arrowGroup = new THREE.Group();
            
            // Corpo da flecha
            const arrowGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 6);
            const arrowMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D });
            const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
            arrow.rotation.x = Math.PI / 2;
            arrowGroup.add(arrow);
            
            // Ponta da flecha
            const arrowheadGeometry = new THREE.ConeGeometry(0.05, 0.1, 6);
            const arrowheadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x808080,
                metalness: 0.8
            });
            const arrowhead = new THREE.Mesh(arrowheadGeometry, arrowheadMaterial);
            arrowhead.position.set(0, 0, 0.3);
            arrowhead.rotation.x = Math.PI / 2;
            arrowGroup.add(arrowhead);
            
            // Penas
            const featherGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.02);
            const featherMaterial = new THREE.MeshStandardMaterial({ color: 0xDDDDDD });
            
            const feather1 = new THREE.Mesh(featherGeometry, featherMaterial);
            feather1.position.set(0, 0, -0.2);
            feather1.rotation.z = Math.PI / 4;
            arrowGroup.add(feather1);
            
            const feather2 = new THREE.Mesh(featherGeometry, featherMaterial);
            feather2.position.set(0, 0, -0.2);
            feather2.rotation.z = -Math.PI / 4;
            arrowGroup.add(feather2);
            
            arrowGroup.position.copy(startPosition);
            
            // Fazer a flecha apontar na dire√ß√£o do alvo
            arrowGroup.lookAt(startPosition.clone().add(direction));
            
            // Adicionar rastro para flecha
            const trailGeometry = new THREE.BufferGeometry();
            const trailMaterial = new THREE.LineBasicMaterial({ 
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.3
            });
            
            const trailPoints = [
                new THREE.Vector3(0, 0, -0.3),
                new THREE.Vector3(0, 0, -0.1)
            ];
            trailGeometry.setFromPoints(trailPoints);
            
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            arrowGroup.add(trail);
            
            const projectile = {
                mesh: arrowGroup,
                direction: direction.clone().normalize(),
                speed: 1.2,
                damage: owner.userData.damage,
                owner: owner,
                lifespan: 50, // frames
                trail: trail
            };
            
            scene.add(arrowGroup);
            projectiles.push(projectile);
            
            return projectile;
        }
        
        function createMagicBall(startPosition, direction, owner) {
            const ballGroup = new THREE.Group();
            
            // Esfera m√°gica
            const ballGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const ballMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00FFFF,
                emissive: 0x00FFFF,
                emissiveIntensity: 0.7,
                transparent: true,
                opacity: 0.8
            });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ballGroup.add(ball);
            
            // Efeito de luz
            const glowGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            ballGroup.add(glow);
            
            // An√©is de energia
            const ringGeometry = new THREE.TorusGeometry(0.2, 0.02, 8, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.7
            });
            
            const ring1 = new THREE.Mesh(ringGeometry, ringMaterial);
            ring1.rotation.x = Math.PI / 2;
            ballGroup.add(ring1);
            
            const ring2 = new THREE.Mesh(ringGeometry, ringMaterial);
            ring2.rotation.y = Math.PI / 2;
            ballGroup.add(ring2);
            
            // Part√≠culas
            for (let i = 0; i < 8; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00FFFF,
                    transparent: true,
                    opacity: 0.7
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Posicionar part√≠culas ao redor da esfera
                const angle = Math.random() * Math.PI * 2;
                const distance = 0.2 + Math.random() * 0.1;
                particle.position.set(
                    Math.cos(angle) * distance,
                    Math.sin(angle) * distance,
                    0
                );
                
                ballGroup.add(particle);
            }
            
            ballGroup.position.copy(startPosition);
            
            // Fazer a bola apontar na dire√ß√£o do alvo
            ballGroup.lookAt(startPosition.clone().add(direction));
            
            // Rastro de energia
            const trailGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(300); // 100 pontos x 3 coordenadas
            
            for (let i = 0; i < 100; i++) {
                const point = startPosition.clone().sub(direction.clone().multiplyScalar(i * 0.05));
                positions[i * 3] = point.x;
                positions[i * 3 + 1] = point.y;
                positions[i * 3 + 2] = point.z;
            }
            
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const trailMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);
            
            const projectile = {
                mesh: ballGroup,
                direction: direction.clone().normalize(),
                speed: 1.0,
                damage: owner.userData.damage,
                owner: owner,
                lifespan: 60, // frames
                glow: glow,
                ring1: ring1,
                ring2: ring2,
                trail: trail,
                trailPositions: positions,
                type: 'magic'
            };
            
            scene.add(ballGroup);
            projectiles.push(projectile);
            
            return projectile;
        }
        
        function createVillage(type) {
            const group = new THREE.Group();
            
            // Base da vila
            const baseGeometry = new THREE.CylinderGeometry(5, 5, 0.5, 16);
            let baseMaterial;
            
            switch(type) {
                case 'warrior':
                    baseMaterial = new THREE.MeshStandardMaterial({ color: 0xB22222 });
                    break;
                case 'archer':
                    baseMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                    break;
                case 'mage':
                    baseMaterial = new THREE.MeshStandardMaterial({ color: 0x4B0082 });
                    break;
                case 'giant':
                    baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    break;
                default:
                    baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            }
            
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.25;
            base.receiveShadow = true;
            group.add(base);
            
            // Adicionar detalhes na base
            const baseDetailGeometry = new THREE.CylinderGeometry(5.2, 5.2, 0.1, 16);
            const baseDetailMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                metalness: 0.5,
                roughness: 0.5
            });
            const baseDetail = new THREE.Mesh(baseDetailGeometry, baseDetailMaterial);
            baseDetail.position.y = 0.5;
            group.add(baseDetail);
            
            // Casas da vila
            const houseCount = Math.floor(Math.random() * 3) + 3;
            for (let i = 0; i < houseCount; i++) {
                const houseGroup = new THREE.Group();
                
                // Tipo de casa baseado no tipo da vila
                if (type === 'warrior') {
                    // Casa de guerreiro - estilo medieval/forte
                    const houseGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                    const houseMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xD2B48C,
                        roughness: 0.8
                    });
                    const house = new THREE.Mesh(houseGeometry, houseMaterial);
                    house.position.y = 0.75;
                    house.castShadow = true;
                    houseGroup.add(house);
                    
                    // Telhado da casa
                    const roofGeometry = new THREE.ConeGeometry(1.2, 1, 4);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 2;
                    roof.rotation.y = Math.PI / 4;
                    roof.castShadow = true;
                    houseGroup.add(roof);
                    
                    // Porta de metal
                    const doorGeometry = new THREE.PlaneGeometry(0.4, 0.8);
                    const doorMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513, 
                        side: THREE.DoubleSide,
                        metalness: 0.3
                    });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(0, 0.4, 0.76);
                    houseGroup.add(door);
                    
                    // Detalhes de metal na porta
                    const doorDetailGeometry = new THREE.PlaneGeometry(0.35, 0.05);
                    const doorDetailMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x696969, 
                        side: THREE.DoubleSide,
                        metalness: 0.8
                    });
                    
                    for (let j = 0; j < 3; j++) {
                        const doorDetail = new THREE.Mesh(doorDetailGeometry, doorDetailMaterial);
                        doorDetail.position.set(0, 0.4 - 0.2 + j * 0.2, 0.77);
                        houseGroup.add(doorDetail);
                    }
                    
                    // Pequena torre de vigia
                    const towerGeometry = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
                    const tower = new THREE.Mesh(towerGeometry, houseMaterial);
                    tower.position.set(0.75, 1, 0.75);
                    houseGroup.add(tower);
                    
                    const towerRoofGeometry = new THREE.ConeGeometry(0.4, 0.5, 8);
                    const towerRoof = new THREE.Mesh(towerRoofGeometry, roofMaterial);
                    towerRoof.position.set(0.75, 2.25, 0.75);
                    houseGroup.add(towerRoof);
                    
                } else if (type === 'archer') {
                    // Casa de arqueiro - estilo cabana de ca√ßador
                    const houseGeometry = new THREE.BoxGeometry(1.6, 1.3, 1.6);
                    const houseMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B7355,
                        roughness: 1.0
                    });
                    const house = new THREE.Mesh(houseGeometry, houseMaterial);
                    house.position.y = 0.65;
                    house.castShadow = true;
                    houseGroup.add(house);
                    
                    // Telhado inclinado da casa
                    const roofGeometry = new THREE.ConeGeometry(1.3, 1.2, 4);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x006400 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 1.8;
                    roof.rotation.y = Math.PI / 4;
                    roof.castShadow = true;
                    houseGroup.add(roof);
                    
                    // Porta de madeira
                    const doorGeometry = new THREE.PlaneGeometry(0.5, 0.7);
                    const doorMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513, 
                        side: THREE.DoubleSide,
                        roughness: 1.0
                    });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(0, 0.3, 0.81);
                    houseGroup.add(door);
                    
                    // Janelas
                    const windowGeometry = new THREE.PlaneGeometry(0.3, 0.3);
                    const windowMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x87CEEB, 
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const window1 = new THREE.Mesh(windowGeometry, windowMaterial);
                    window1.position.set(0.4, 0.7, 0.81);
                    window1.position.set(0.4, 0.7, 0.81);
                    houseGroup.add(window1);
                    
                    const window2 = new THREE.Mesh(windowGeometry, windowMaterial);
                    window2.position.set(-0.4, 0.7, 0.81);
                    houseGroup.add(window2);
                    
                    // Alvo de tiro no quintal
                    const targetStandGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                    const targetStandMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const targetStand = new THREE.Mesh(targetStandGeometry, targetStandMaterial);
                    targetStand.position.set(1, 0.5, 1);
                    houseGroup.add(targetStand);
                    
                    const targetGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16);
                    const targetMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                    const target = new THREE.Mesh(targetGeometry, targetMaterial);
                    target.rotation.x = Math.PI / 2;
                    target.position.set(1, 1, 1);
                    houseGroup.add(target);
                    
                    const bullseyeGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.06, 16);
                    const bullseyeMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
                    const bullseye = new THREE.Mesh(bullseyeGeometry, bullseyeMaterial);
                    bullseye.rotation.x = Math.PI / 2;
                    bullseye.position.set(1, 1, 1.01);
                    houseGroup.add(bullseye);
                    
                } else if (type === 'mage') {
                    // Casa de mago - torre arcana
                    const towerGeometry = new THREE.CylinderGeometry(0.8, 1, 2.5, 8);
                    const towerMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x4B0082,
                        roughness: 0.7
                    });
                    const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                    tower.position.y = 1.25;
                    tower.castShadow = true;
                    houseGroup.add(tower);
                    
                    // Topo da torre (c√∫pula)
                    const domeGeometry = new THREE.SphereGeometry(1, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                    const domeMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x9370DB,
                        metalness: 0.3,
                        roughness: 0.7
                    });
                    const dome = new THREE.Mesh(domeGeometry, domeMaterial);
                    dome.position.y = 2.5;
                    dome.castShadow = true;
                    houseGroup.add(dome);
                    
                    // Espiral no topo da torre
                    const spiralGeometry = new THREE.ConeGeometry(0.2, 0.8, 8);
                    const spiralMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x4B0082,
                        metalness: 0.3
                    });
                    const spiral = new THREE.Mesh(spiralGeometry, spiralMaterial);
                    spiral.position.y = 3.1;
                    spiral.castShadow = true;
                    houseGroup.add(spiral);
                    
                    // Esfera m√°gica no topo
                    const orbGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const orbMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00FFFF,
                        emissive: 0x00FFFF,
                        emissiveIntensity: 0.5,
                        transparent: true,
                        opacity: 0.8
                    });
                    const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                    orb.position.y = 3.5;
                    houseGroup.add(orb);
                    
                    // Efeito de brilho na esfera
                    const glowGeometry = new THREE.SphereGeometry(0.25, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x00FFFF,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    glow.position.y = 3.5;
                    houseGroup.add(glow);
                    
                    // Janelas arcanas
                    for (let j = 0; j < 4; j++) {
                        const angle = (j / 4) * Math.PI * 2;
                        const windowGeometry = new THREE.PlaneGeometry(0.3, 0.6);
                        const windowMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x00FFFF,
                            emissive: 0x00FFFF,
                            emissiveIntensity: 0.2,
                            transparent: true,
                            opacity: 0.5,
                            side: THREE.DoubleSide
                        });
                        
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        window.position.set(
                            Math.cos(angle) * 0.9,
                            1.25,
                            Math.sin(angle) * 0.9
                        );
                        window.rotation.y = angle;
                        houseGroup.add(window);
                    }
                    
                    // Porta arcana
                    const doorGeometry = new THREE.PlaneGeometry(0.5, 0.9);
                    const doorMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x4B0082,
                        emissive: 0x9370DB,
                        emissiveIntensity: 0.1,
                        side: THREE.DoubleSide,
                        metalness: 0.7
                    });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(0, 0.45, 1.01);
                    houseGroup.add(door);
                    
                    // S√≠mbolo arcano na porta
                    const symbolGeometry = new THREE.CircleGeometry(0.15, 5);
                    const symbolMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00FFFF,
                        emissive: 0x00FFFF,
                        emissiveIntensity: 0.5,
                        side: THREE.DoubleSide
                    });
                    const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
                    symbol.position.set(0, 0.45, 1.02);
                    houseGroup.add(symbol);
                    
                } else if (type === 'giant') {
                    // Casa de gigante - fortaleza robusta
                    const houseGeometry = new THREE.BoxGeometry(2, 2, 2);
                    const houseMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513,
                        roughness: 0.9
                    });
                    const house = new THREE.Mesh(houseGeometry, houseMaterial);
                    house.position.y = 1;
                    house.castShadow = true;
                    houseGroup.add(house);
                    
                    // Telhado robusto
                    const roofGeometry = new THREE.BoxGeometry(2.4, 0.5, 2.4);
                    const roofMaterial = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
                    const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                    roof.position.y = 2.25;
                    roof.castShadow = true;
                    houseGroup.add(roof);
                    
                    // Pilares 
                    const pillarGeometry = new THREE.BoxGeometry(0.4, 2, 0.4);
                    const pillarMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x696969,
                        roughness: 0.8
                    });
                    
                    const positions = [
                        [1, 0, 1],
                        [1, 0, -1],
                        [-1, 0, 1],
                        [-1, 0, -1]
                    ];
                    
                    for (const pos of positions) {
                        const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                        pillar.position.set(pos[0], 1, pos[2]);
                        houseGroup.add(pillar);
                    }
                    
                    // Grande porta
                    const doorGeometry = new THREE.PlaneGeometry(0.8, 1.2);
                    const doorMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B0000, 
                        side: THREE.DoubleSide,
                        metalness: 0.5,
                        roughness: 0.5
                    });
                    const door = new THREE.Mesh(doorGeometry, doorMaterial);
                    door.position.set(0, 0.6, 1.01);
                    houseGroup.add(door);
                    
                    // Detalhes de metal na porta
                    const doorDetailHGeometry = new THREE.PlaneGeometry(0.7, 0.1);
                    const doorDetailVGeometry = new THREE.PlaneGeometry(0.1, 1.1);
                    const doorDetailMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x696969, 
                        side: THREE.DoubleSide,
                        metalness: 0.8
                    });
                    
                    const doorHDetail1 = new THREE.Mesh(doorDetailHGeometry, doorDetailMaterial);
                    doorHDetail1.position.set(0, 0.2, 1.02);
                    houseGroup.add(doorHDetail1);
                    
                    const doorHDetail2 = new THREE.Mesh(doorDetailHGeometry, doorDetailMaterial);
                    doorHDetail2.position.set(0, 1, 1.02);
                    houseGroup.add(doorHDetail2);
                    
                    const doorVDetail = new THREE.Mesh(doorDetailVGeometry, doorDetailMaterial);
                    doorVDetail.position.set(0, 0.6, 1.02);
                    houseGroup.add(doorVDetail);
                    
                    // Pele de animal na parede (trof√©u)
                    const trophyGeometry = new THREE.PlaneGeometry(1, 0.8);
                    const trophyMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xA0522D, 
                        side: THREE.DoubleSide,
                        roughness: 1.0
                    });
                    const trophy = new THREE.Mesh(trophyGeometry, trophyMaterial);
                    trophy.position.set(0, 1.5, 1.01);
                    houseGroup.add(trophy);
                }
                
                // Posicionar casa aleatoriamente na vila
                const angle = (i / houseCount) * Math.PI * 2;
                const radius = Math.random() * 2 + 2;
                houseGroup.position.x = Math.cos(angle) * radius;
                houseGroup.position.z = Math.sin(angle) * radius;
                houseGroup.rotation.y = Math.random() * Math.PI * 2;
                
                group.add(houseGroup);
            }
            
            // Bandeira que indica o tipo de vila
            const flagpoleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
            const flagpoleMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
            const flagpole = new THREE.Mesh(flagpoleGeometry, flagpoleMaterial);
            flagpole.position.set(0, 1.5, 0);
            flagpole.castShadow = true;
            group.add(flagpole);
            
            const flagGeometry = new THREE.PlaneGeometry(1, 0.6);
            let flagMaterial;
            
            switch(type) {
                case 'warrior':
                    flagMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xB22222, 
                        side: THREE.DoubleSide,
                        roughness: 0.7
                    });
                    break;
                case 'archer':
                    flagMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x228B22, 
                        side: THREE.DoubleSide,
                        roughness: 0.7
                    });
                    break;
                case 'mage':
                    flagMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x4B0082, 
                        side: THREE.DoubleSide,
                        roughness: 0.7
                    });
                    break;
                case 'giant':
                    flagMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513, 
                        side: THREE.DoubleSide,
                        roughness: 0.7
                    });
                    break;
                default:
                    flagMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xFFD700, 
                        side: THREE.DoubleSide,
                        roughness: 0.7
                    });
            }
            
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.set(0.5, 2.7, 0);
            flag.rotation.y = Math.PI / 2;
            flag.castShadow = true;
            group.add(flag);
            
            // Criar s√≠mbolo do tipo na bandeira
            let symbol;
            switch(type) {
                case 'warrior':
                    // S√≠mbolo de espada
                    const swordGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.01);
                    const swordMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xFFFFFF,
                        metalness: 0.8,
                        roughness: 0.2,
                        side: THREE.DoubleSide
                    });
                    symbol = new THREE.Mesh(swordGeometry, swordMaterial);
                    symbol.rotation.z = Math.PI / 4;
                    
                    // Guarda da espada
                    const guardGeometry = new THREE.BoxGeometry(0.15, 0.03, 0.01);
                    const guard = new THREE.Mesh(guardGeometry, swordMaterial);
                    symbol.add(guard);
                    break;
                    
                case 'archer':
                    // S√≠mbolo de arco e flecha
                    const bowGeometry = new THREE.TorusGeometry(0.1, 0.01, 8, 12, Math.PI);
                    const bowMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xFFFFFF,
                        side: THREE.DoubleSide
                    });
                    symbol = new THREE.Mesh(bowGeometry, bowMaterial);
                    
                    // Flecha
                    const arrowGeometry = new THREE.BoxGeometry(0.01, 0.2, 0.01);
                    const arrow = new THREE.Mesh(arrowGeometry, bowMaterial);
                    arrow.position.y = -0.05;
                    symbol.add(arrow);
                    
                    // Ponta da flecha
                    const arrowheadGeometry = new THREE.ConeGeometry(0.02, 0.04, 8);
                    const arrowhead = new THREE.Mesh(arrowheadGeometry, bowMaterial);
                    arrowhead.position.y = -0.17;
                    arrowhead.rotation.x = Math.PI;
                    symbol.add(arrowhead);
                    break;
                    
                case 'mage':
                    // S√≠mbolo de cajado m√°gico
                    const staffGeometry = new THREE.BoxGeometry(0.02, 0.3, 0.01);
                    const staffMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xFFFFFF,
                        side: THREE.DoubleSide
                    });
                    symbol = new THREE.Mesh(staffGeometry, staffMaterial);
                    
                    // Orbe no topo do cajado
                    const orbeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                    const orbeMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x00FFFF,
                        emissive: 0x00FFFF,
                        emissiveIntensity: 0.5,
                        side: THREE.DoubleSide
                    });
                    const orbe = new THREE.Mesh(orbeGeometry, orbeMaterial);
                    orbe.position.y = 0.15;
                    symbol.add(orbe);
                    break;
                    
                case 'giant':
                    // S√≠mbolo de martelo
                    const handleGeometry = new THREE.BoxGeometry(0.03, 0.3, 0.01);
                    const hammerMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xFFFFFF,
                        side: THREE.DoubleSide
                    });
                    symbol = new THREE.Mesh(handleGeometry, hammerMaterial);
                    
                    // Cabe√ßa do martelo
                    const headGeometry = new THREE.BoxGeometry(0.15, 0.08, 0.01);
                    const head = new THREE.Mesh(headGeometry, hammerMaterial);
                    head.position.y = 0.15;
                    symbol.add(head);
                    break;
                    
                default:
                    symbol = new THREE.Mesh(
                        new THREE.CircleGeometry(0.1, 16),
                        new THREE.MeshStandardMaterial({ 
                            color: 0xFFFFFF,
                            side: THREE.DoubleSide
                        })
                    );
            }
            
            if (symbol) {
                symbol.position.set(0.5, 2.7, 0.01);
                symbol.rotation.y = Math.PI / 2;
                group.add(symbol);
            }
            
            // Indicador de disponibilidade
            const indicatorGeometry = new THREE.CylinderGeometry(5.3, 5.3, 0.1, 32);
            const indicatorMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00FF00,
                transparent: true,
                opacity: 0.5
            });
            const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
            indicator.position.y = 0.05;
            group.add(indicator);
            
            group.userData = {
                type: type,
                cooldown: 0,
                maxCooldown: 15,
                available: true,
                indicator: indicator,
                flag: flag,
                flagVisibility: true
            };
            
            return group;
        }
        
        // Criar jogador
        const player = createPenguin(true);
        player.position.set(0, 0, 0);
        player.userData.isInBattle = false;
        scene.add(player);
        
        // Criar bots
        for (let i = 0; i < BOT_COUNT; i++) {
            const bot = {
                mesh: createPenguin(false, i === 0), // Primeiro bot √© l√≠der inicial
                name: botNames[i],
                soldiers: [],
                score: 0,
                target: new THREE.Vector3(
                    Math.random() * 180 - 90,
                    0,
                    Math.random() * 180 - 90
                ),
                isInBattle: false,
                battleWith: null,
                powerups: {
                    speed: {
                        active: false,
                        multiplier: 1.0,
                        duration: 0,
                        maxDuration: 30
                    },
                    strength: {
                        active: false,
                        multiplier: 1.0,
                        duration: 0,
                        maxDuration: 30
                    }
                }
            };
            
            bot.mesh.position.set(
                Math.random() * 180 - 90,
                0,
                Math.random() * 180 - 90
            );
            
            scene.add(bot.mesh);
            bots.push(bot);
        }
        
        // Criar vilas
        const villageTypes = ['warrior', 'archer', 'mage', 'giant'];
        for (let i = 0; i < 20; i++) {
            const type = villageTypes[Math.floor(Math.random() * villageTypes.length)];
            const village = createVillage(type);
            
            // Posicionar vilas aleatoriamente, mas n√£o muito pr√≥ximas umas das outras
            let validPosition = false;
            let attempts = 0;
            let position;
            
            while (!validPosition && attempts < 100) {
                position = new THREE.Vector3(
                    Math.random() * 180 - 90,
                    0,
                    Math.random() * 180 - 90
                );
                
                validPosition = true;
                
                // Verificar dist√¢ncia de outras vilas
                for (const otherVillage of villages) {
                    if (position.distanceTo(otherVillage.position) < 20) {
                        validPosition = false;
                        break;
                    }
                }
                
                // Verificar dist√¢ncia de √°rvores e pedras
                for (const tree of trees) {
                    if (position.distanceTo(tree.position) < 10) {
                        validPosition = false;
                        break;
                    }
                }
                
                for (const rock of rocks) {
                    if (position.distanceTo(rock.position) < 8) {
                        validPosition = false;
                        break;
                    }
                }
                
                attempts++;
            }
            
            if (validPosition) {
                village.position.copy(position);
                scene.add(village);
                villages.push(village);
            }
        }
        
        // Configurar controles de forma√ß√£o
        document.getElementById('formationCircle').addEventListener('click', function() {
            currentFormation = 'circle';
            document.querySelectorAll('.formation-btn').forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
        });
        
        document.getElementById('formationLine').addEventListener('click', function() {
            currentFormation = 'line';
            document.querySelectorAll('.formation-btn').forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
        });
        
        document.getElementById('formationArrow').addEventListener('click', function() {
            currentFormation = 'arrow';
            document.querySelectorAll('.formation-btn').forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
        });
        
        // Controles do jogador
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };
        
        window.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() in keys) {
                keys[e.key.toLowerCase()] = true;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() in keys) {
                keys[e.key.toLowerCase()] = false;
            }
        });
        
        // Zoom com scroll
        window.addEventListener('wheel', (e) => {
            const newY = camera.position.y - e.deltaY * 0.05;
            camera.position.y = Math.max(10, Math.min(60, newY));
        });
        
        // Atualizar HUD
        function updateHUD() {
            document.getElementById('playerName').textContent = `${playerName}`;
            document.getElementById('score').textContent = `Pontua√ß√£o: ${playerScore}`;
            document.getElementById('soldierCount').textContent = `Soldados: ${playerSoldiers.length}/${MAX_SOLDIERS}`;
            
            // Status de velocidade
            const speedText = playerPowerups.speed.active ? `Velocidade: Aumentada (${Math.floor(playerPowerups.speed.duration)}s)` : "Velocidade: Normal";
            document.getElementById('playerSpeed').textContent = speedText;
            
            // Status de for√ßa
            const strengthText = playerPowerups.strength.active ? `For√ßa: Aumentada (${Math.floor(playerPowerups.strength.duration)}s)` : "For√ßa: Normal";
            document.getElementById('playerStrength').textContent = strengthText;
            
            // Atualizar indicadores de power-up
            const speedPowerup = document.getElementById('speedPowerup');
            const strengthPowerup = document.getElementById('strengthPowerup');
            
            if (playerPowerups.speed.active) {
                speedPowerup.classList.add('powerup-active');
                speedPowerup.querySelector('.powerup-timer').textContent = Math.floor(playerPowerups.speed.duration);
            } else {
                speedPowerup.classList.remove('powerup-active');
                speedPowerup.querySelector('.powerup-timer').textContent = '';
            }
            
            if (playerPowerups.strength.active) {
                strengthPowerup.classList.add('powerup-active');
                strengthPowerup.querySelector('.powerup-timer').textContent = Math.floor(playerPowerups.strength.duration);
            } else {
                strengthPowerup.classList.remove('powerup-active');
                strengthPowerup.querySelector('.powerup-timer').textContent = '';
            }
            
            // Atualizar timer
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            document.getElementById('timer').textContent = `‚è±Ô∏è ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
            
            // Batalha
            const battleInfo = document.getElementById('battleInfo');
            const formationButtons = document.getElementById('formationButtons');
            
            if (player.userData.isInBattle) {
                battleInfo.style.display = 'block';
                formationButtons.style.display = 'flex';
            } else {
                battleInfo.style.display = 'none';
                formationButtons.style.display = 'none';
            }
            
            // Atualizar ranking
            const allPlayers = [
                { name: playerName, score: playerScore, isPlayer: true },
                ...bots.map(bot => ({ name: bot.name, score: bot.score, isPlayer: false }))
            ];
            
            allPlayers.sort((a, b) => b.score - a.score);
            
            let rankingHTML = '';
            for (let i = 0; i < allPlayers.length; i++) {
                const isPlayer = allPlayers[i].isPlayer;
                const isFirst = i === 0;
                const cssClass = isFirst ? 'rank-first' : (isPlayer ? 'rank-player' : '');
                
                rankingHTML += `
                    <div class="rank-item ${cssClass}">
                        <div class="rank-icon">${isFirst ? 'üëë' : (i+1)}</div>
                        ${allPlayers[i].name}: ${allPlayers[i].score}
                    </div>
                `;
            }
            
            document.getElementById('rankingList').innerHTML = rankingHTML;
            
            // Atualizar coroa do l√≠der
            updateLeaderCrown(allPlayers[0].isPlayer ? player : bots.find(b => b.name === allPlayers[0].name).mesh);
        }
        
        function updateLeaderCrown(leaderMesh) {
            // Remover coroa de todos
            player.userData.leaderCrown.visible = false;
            player.userData.hasCrown = false;
            
            for (const bot of bots) {
                bot.mesh.userData.leaderCrown.visible = false;
                bot.mesh.userData.hasCrown = false;
            }
            
            // Adicionar coroa somente ao l√≠der
            if (leaderMesh === player) {
                player.userData.leaderCrown.visible = true;
                player.userData.hasCrown = true;
            } else {
                for (const bot of bots) {
                    if (bot.mesh === leaderMesh) {
                        bot.mesh.userData.leaderCrown.visible = true;
                        bot.mesh.userData.hasCrown = true;
                        break;
                    }
                }
            }
        }
        
        function createCrownForLeader(mesh) {
            // Criar uma coroa detalhada
            const crownGroup = new THREE.Group();
            
            const crownBaseGeometry = new THREE.CylinderGeometry(0.6, 0.8, 0.4, 8);
            const crownMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                metalness: 0.8,
                roughness: 0.2
            });
            const crownBase = new THREE.Mesh(crownBaseGeometry, crownMaterial);
            crownBase.position.y = 0.2;
            crownGroup.add(crownBase);
            
            // Pontas da coroa
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const spike = new THREE.Mesh(
                    new THREE.ConeGeometry(0.15, 0.5, 4),
                    crownMaterial
                );
                spike.position.set(
                    Math.cos(angle) * 0.6,
                    0.6,
                    Math.sin(angle) * 0.6
                );
                crownGroup.add(spike);
            }
            
            // Joias da coroa
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2 + Math.PI / 5;
                const jewelGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const jewelMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.2,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const jewel = new THREE.Mesh(jewelGeometry, jewelMaterial);
                jewel.position.set(
                    Math.cos(angle) * 0.7,
                    0.2,
                    Math.sin(angle) * 0.7
                );
                crownGroup.add(jewel);
            }
            
            crownGroup.position.y = 3;
            crownGroup.visible = false;
            mesh.add(crownGroup);
            
            mesh.userData.leaderCrown = crownGroup;
        }
        
        // Verificar colis√£o com vilas
        function checkVillageCollision() {
            for (const village of villages) {
                if (player.position.distanceTo(village.position) < 5 && village.userData.available && playerSoldiers.length < MAX_SOLDIERS) {
                    recruitSoldier(village.userData.type);
                    village.userData.available = false;
                    village.userData.cooldown = village.userData.maxCooldown;
                    village.userData.indicator.material.color.set(0xFF0000);
                    
                    // Esconder a bandeira quando a vila n√£o est√° dispon√≠vel
                    village.userData.flag.visible = false;
                    village.userData.flagVisibility = false;
                }
            }
        }
        
        // Verificar colis√£o com power-ups
        function checkPowerupCollision() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                
                if (player.position.distanceTo(powerup.position) < 2) {
                    // Ativar power-up para o jogador
                    activatePowerup(powerup.userData.type);
                    
                    // Remover o power-up do mapa
                    scene.remove(powerup);
                    powerups.splice(i, 1);
                    
                    // Adicionar pontos
                    playerScore += 5;
                }
            }
        }
        
        function activatePowerup(type) {
            if (type === 'speed') {
                playerPowerups.speed.active = true;
                playerPowerups.speed.multiplier = 2.0;
                playerPowerups.speed.duration = playerPowerups.speed.maxDuration;
            } else if (type === 'strength') {
                playerPowerups.strength.active = true;
                playerPowerups.strength.multiplier = 2.0;
                playerPowerups.strength.duration = playerPowerups.strength.maxDuration;
                
                // Aplicar for√ßa extra aos soldados
                for (const soldier of playerSoldiers) {
                    soldier.userData.damage = soldier.userData.originalStrength * playerPowerups.strength.multiplier;
                }
            }
        }
        
        function updatePowerups(delta) {
            // Atualizar timers de power-ups
            if (playerPowerups.speed.active) {
                playerPowerups.speed.duration -= delta;
                if (playerPowerups.speed.duration <= 0) {
                    playerPowerups.speed.active = false;
                    playerPowerups.speed.multiplier = 1.0;
                }
            }
            
            if (playerPowerups.strength.active) {
                playerPowerups.strength.duration -= delta;
                if (playerPowerups.strength.duration <= 0) {
                    playerPowerups.strength.active = false;
                    playerPowerups.strength.multiplier = 1.0;
                    
                    // Restaurar for√ßa normal dos soldados
                    for (const soldier of playerSoldiers) {
                        soldier.userData.damage = soldier.userData.originalStrength;
                    }
                }
            }
            
            // Animar power-ups no mapa
            for (const powerup of powerups) {
                // Flutua√ß√£o
                powerup.userData.floatOffset += powerup.userData.floatSpeed;
                powerup.position.y = Math.sin(powerup.userData.floatOffset) * powerup.userData.floatHeight;
                
                // Rota√ß√£o
                powerup.rotation.y += powerup.userData.rotationSpeed;
                
                // Pulsar efeito de brilho
                powerup.userData.glowPulse += 0.05;
                const scale = 1 + Math.sin(powerup.userData.glowPulse) * 0.2;
                powerup.userData.glowMesh.scale.set(scale, scale, scale);
            }
            
            // Atualizar power-ups dos bots
            for (const bot of bots) {
                if (bot.powerups.speed.active) {
                    bot.powerups.speed.duration -= delta;
                    if (bot.powerups.speed.duration <= 0) {
                        bot.powerups.speed.active = false;
                        bot.powerups.speed.multiplier = 1.0;
                    }
                }
                
                if (bot.powerups.strength.active) {
                    bot.powerups.strength.duration -= delta;
                    if (bot.powerups.strength.duration <= 0) {
                        bot.powerups.strength.active = false;
                        bot.powerups.strength.multiplier = 1.0;
                        
                        // Restaurar for√ßa normal dos soldados
                        for (const soldier of bot.soldiers) {
                            soldier.userData.damage = soldier.userData.originalStrength;
                        }
                    }
                }
            }
        }
        
        // Calcular posi√ß√£o para cada soldado com base na forma√ß√£o
        function getFormationPosition(index, totalSoldiers, leaderPosition, battleDirection = null) {
            let position = new THREE.Vector3();
            
            // Dire√ß√£o padr√£o para forma√ß√µes quando n√£o estiver em batalha
            const defaultFormationDirection = new THREE.Vector3(0, 0, 1);
            const direction = battleDirection || defaultFormationDirection;
            
            // Vetor perpendicular √† dire√ß√£o
            const perpDirection = new THREE.Vector3(-direction.z, 0, direction.x).normalize();
            
            switch (currentFormation) {
                case 'circle':
                    // Forma√ß√£o circular
                    const angle = (index / totalSoldiers) * Math.PI * 2;
                    const radius = 3 + Math.random() * 0.5;
                    position.x = Math.cos(angle) * radius;
                    position.z = Math.sin(angle) * radius;
                    break;
                
                case 'line':
                    // Forma√ß√£o em linha
                    const lineWidth = 6; // Largura total da linha
                    const spacing = lineWidth / (totalSoldiers || 1);
                    const offset = (index - (totalSoldiers - 1) / 2) * spacing;
                    position.x = perpDirection.x * offset;
                    position.z = perpDirection.z * offset;
                    
                    // Dist√¢ncia √† frente
                    position.add(direction.clone().multiplyScalar(2));
                    break;
                
                case 'arrow':
                    // Forma√ß√£o em cunha/flecha
                    const frontCount = Math.ceil(totalSoldiers / 3);
                    
                    if (index < frontCount) {
                        // Primeira fila (ponta da flecha)
                        const arrowWidth = 4;
                        const arrowSpacing = arrowWidth / (frontCount || 1);
                        const arrowOffset = (index - (frontCount - 1) / 2) * arrowSpacing;
                        position.x = perpDirection.x * arrowOffset;
                        position.z = perpDirection.z * arrowOffset;
                        position.add(direction.clone().multiplyScalar(4));
                    } else {
                        // Soldados atr√°s
                        const row = Math.floor((index - frontCount) / 4) + 1;
                        const col = (index - frontCount) % 4;
                        const rowWidth = 5 + row;
                        const colSpacing = rowWidth / 4;
                        const colOffset = (col - 1.5) * colSpacing;
                        
                        position.x = perpDirection.x * colOffset;
                        position.z = perpDirection.z * colOffset;
                        position.add(direction.clone().multiplyScalar(4 - row * 1.5));
                    }
                    break;
                
                default:
                    // Forma√ß√£o em c√≠rculo por padr√£o
                    const defaultAngle = (index / totalSoldiers) * Math.PI * 2;
                    const defaultRadius = 3 + Math.random() * 0.5;
                    position.x = Math.cos(defaultAngle) * defaultRadius;
                    position.z = Math.sin(defaultAngle) * defaultRadius;
            }
            
            // Adicionar alguma varia√ß√£o natural
            position.x += (Math.random() - 0.5) * 0.5;
            position.z += (Math.random() - 0.5) * 0.5;
            
            // Posi√ß√£o relativa ao l√≠der
            position.add(leaderPosition);
            
            return position;
        }
        
        // Contratar soldado
        function recruitSoldier(type) {
            if (playerSoldiers.length >= MAX_SOLDIERS) return;
            
            let soldier;
            switch(type) {
                case 'warrior':
                    soldier = createWarrior();
                    break;
                case 'archer':
                    soldier = createArcher();
                    break;
                case 'mage':
                    soldier = createMage();
                    break;
                case 'giant':
                    soldier = createGiant();
                    break;
                default:
                    soldier = createWarrior();
            }
            
            if (soldier) {
                // Posi√ß√£o inicial do soldado
                const angle = Math.random() * Math.PI * 2;
                const distance = 2 + Math.random();
                soldier.position.x = player.position.x + Math.cos(angle) * distance;
                soldier.position.z = player.position.z + Math.sin(angle) * distance;
                
                // Aplicar for√ßa baseada em power-up
                if (playerPowerups.strength.active) {
                    soldier.userData.damage = soldier.userData.originalStrength * playerPowerups.strength.multiplier;
                }
                
                // Definir forma√ß√£o e comportamento inicial
                soldier.userData.formationIndex = playerSoldiers.length;
                
                scene.add(soldier);
                playerSoldiers.push(soldier);
                playerScore += 5;
            }
        }
        
        function updateAttackAnimation(soldier, delta) {
            if (soldier.userData.isAttacking) {
                soldier.userData.attackTime += delta;
                
                if (soldier.userData.type === 'warrior') {
                    // Anima√ß√£o de ataque para guerreiro
                    const attackDuration = 0.5; // dura√ß√£o em segundos
                    const progress = Math.min(soldier.userData.attackTime / attackDuration, 1);
                    
                    // Animar espada
                    if (progress < 0.5) {
                        // Levantar espada
                        const angle = Math.PI / 4 + progress * Math.PI;
                        soldier.userData.sword.rotation.z = angle;
                    } else {
                        // Baixar espada
                        const angle = Math.PI * 1.25 - (progress - 0.5) * 2 * Math.PI;
                        soldier.userData.sword.rotation.z = angle;
                    }
                    
                    if (progress >= 1) {
                        soldier.userData.isAttacking = false;
                        soldier.userData.attackTime = 0;
                        soldier.userData.sword.rotation.z = Math.PI / 4; // posi√ß√£o inicial
                    }
                } 
                else if (soldier.userData.type === 'archer') {
                    // Anima√ß√£o de ataque para arqueiro
                    const attackDuration = 0.5; // dura√ß√£o em segundos
                    const progress = Math.min(soldier.userData.attackTime / attackDuration, 1);
                    
                    // Animar arco
                    if (progress < 0.5) {
                        // Esticar arco
                        soldier.userData.bow.scale.x = 1 - progress * 0.3;
                    } else {
                        // Soltar arco
                        soldier.userData.bow.scale.x = 0.7 + (progress - 0.5) * 0.6;
                    }
                    
                    if (progress >= 1) {
                        soldier.userData.isAttacking = false;
                        soldier.userData.attackTime = 0;
                        soldier.userData.bow.scale.x = 1; // posi√ß√£o inicial
                    }
                }
                else if (soldier.userData.type === 'mage') {
                    // Anima√ß√£o de ataque para mago
                    const attackDuration = 0.6; // dura√ß√£o em segundos
                    const progress = Math.min(soldier.userData.attackTime / attackDuration, 1);
                    
                    // Animar cajado e orbe
                    if (progress < 0.3) {
                        // Levantar cajado
                        soldier.userData.staff.rotation.z = Math.PI / 12 - progress * Math.PI / 2;
                        
                        // Aumentar brilho do orbe
                        soldier.userData.orbe.material.emissiveIntensity = 0.5 + progress * 1.5;
                        soldier.userData.glow.scale.set(1 + progress, 1 + progress, 1 + progress);
                    } 
                    else if (progress < 0.5) {
                        // Manter cajado erguido e orbe brilhando
                        soldier.userData.staff.rotation.z = -Math.PI / 12 * 2;
                        soldier.userData.orbe.material.emissiveIntensity = 2.0;
                    } 
                    else {
                        // Baixar cajado e diminuir brilho
                        const lowerProgress = (progress - 0.5) / 0.5;
                        soldier.userData.staff.rotation.z = -Math.PI / 12 * 2 + lowerProgress * Math.PI / 3;
                        soldier.userData.orbe.material.emissiveIntensity = 2.0 - lowerProgress * 1.5;
                        soldier.userData.glow.scale.set(1.3 - lowerProgress * 0.3, 1.3 - lowerProgress * 0.3, 1.3 - lowerProgress * 0.3);
                    }
                    
                    if (progress >= 1) {
                        soldier.userData.isAttacking = false;
                        soldier.userData.attackTime = 0;
                        soldier.userData.staff.rotation.z = Math.PI / 12; // posi√ß√£o inicial
                        soldier.userData.orbe.material.emissiveIntensity = 0.5; // brilho inicial
                        soldier.userData.glow.scale.set(1, 1, 1); // tamanho inicial
                    }
                }
                else if (soldier.userData.type === 'giant') {
                    // Anima√ß√£o de ataque para gigante
                    const attackDuration = 0.8; // dura√ß√£o em segundos
                    const progress = Math.min(soldier.userData.attackTime / attackDuration, 1);
                    
                    // Animar martelo
                    if (progress < 0.4) {
                        // Levantar martelo
                        const angle = Math.PI / 3 - progress * Math.PI;
                        soldier.userData.hammer.rotation.z = angle;
                    } 
                    else if (progress < 0.5) {
                        // Segurar no alto
                        soldier.userData.hammer.rotation.z = -Math.PI / 3 * 2;
                    } 
                    else if (progress < 0.6) {
                        // Golpe poderoso
                        const smashProgress = (progress - 0.5) / 0.1;
                        soldier.userData.hammer.rotation.z = -Math.PI / 3 * 2 + smashProgress * Math.PI;
                    } 
                    else {
                        // Voltar √† posi√ß√£o
                        const returnProgress = (progress - 0.6) / 0.4;
                        soldier.userData.hammer.rotation.z = Math.PI / 3 * 1 - returnProgress * Math.PI / 3 * 0.7;
                    }
                    
                    if (progress >= 1) {
                        soldier.userData.isAttacking = false;
                        soldier.userData.attackTime = 0;
                        soldier.userData.hammer.rotation.z = Math.PI / 3; // posi√ß√£o inicial
                    }
                }
            }
        }
        
        // Verificar batalhas entre jogadores
        function checkBattles() {
            // Verificar batalha entre jogador e bots
            for (const bot of bots) {
                const distance = player.position.distanceTo(bot.mesh.position);
                
                if (distance < 10) {
                    // Se n√£o est√£o em batalha ainda, iniciar batalha
                    if (!player.userData.isInBattle && !bot.isInBattle) {
                        startBattle(player, bot);
                    }
                } 
                else if (player.userData.isInBattle && player.userData.battleWith === bot) {
                    // Se est√£o muito distantes, encerrar batalha
                    if (distance > 15) {
                        endBattle(player, bot);
                    }
                }
                
                // Verificar se o bot perdeu todos os soldados
                if (bot.isInBattle && bot.soldiers.length === 0) {
                    // Bot perdeu todos os soldados, encerrar batalha
                    if (bot.battleWith === player) {
                        endBattle(player, bot);
                    } else if (bot.battleWith) {
                        endBattleBetweenBots(bot.battleWith, bot);
                    }
                }
            }
            
            // Verificar se o player perdeu todos os soldados
            if (player.userData.isInBattle && playerSoldiers.length === 0) {
                const opponent = player.userData.battleWith;
                if (opponent) {
                    endBattle(player, opponent);
                }
            }
            
            // Verificar batalhas entre bots
            for (let i = 0; i < bots.length; i++) {
                for (let j = i + 1; j < bots.length; j++) {
                    const bot1 = bots[i];
                    const bot2 = bots[j];
                    
                    const distance = bot1.mesh.position.distanceTo(bot2.mesh.position);
                    
                    if (distance < 10) {
                        // Se n√£o est√£o em batalha ainda, iniciar batalha
                        if (!bot1.isInBattle && !bot2.isInBattle) {
                            startBattleBetweenBots(bot1, bot2);
                        }
                    } 
                    else if (bot1.isInBattle && bot1.battleWith === bot2) {
                        // Se est√£o muito distantes, encerrar batalha
                        if (distance > 15) {
                            endBattleBetweenBots(bot1, bot2);
                        }
                    }
                    
                    // Verificar se um dos bots perdeu todos os soldados
                    if (bot1.isInBattle && bot1.battleWith === bot2) {
                        if (bot1.soldiers.length === 0 || bot2.soldiers.length === 0) {
                            endBattleBetweenBots(bot1, bot2);
                        }
                    }
                }
            }
        }
        
        function startBattle(player, bot) {
            // Definir estado de batalha
            player.userData.isInBattle = true;
            player.userData.battleWith = bot;
            
            bot.isInBattle = true;
            bot.battleWith = player;
            
            // Atualizar estado de combate dos soldados
            for (const soldier of playerSoldiers) {
                soldier.userData.behaviourState = 'battle';
            }
            
            for (const soldier of bot.soldiers) {
                soldier.userData.behaviourState = 'battle';
            }
            
            // Criar marcador de batalha
            const battlePos = new THREE.Vector3().addVectors(player.position, bot.mesh.position).multiplyScalar(0.5);
            const battleMarker = createBattleMarker();
            battleMarker.position.copy(battlePos);
            battleMarker.userData.player = player;
            battleMarker.userData.bot = bot;
            
            scene.add(battleMarker);
            battleMarkers.push(battleMarker);
            
            // Mostrar interface de combate
            document.getElementById('battleInfo').style.display = 'block';
            document.getElementById('formationButtons').style.display = 'flex';
        }
        
        function endBattle(player, bot) {
            // Remover estado de batalha
            player.userData.isInBattle = false;
            player.userData.battleWith = null;
            
            bot.isInBattle = false;
            bot.battleWith = null;
            
            // Atualizar estado de combate dos soldados
            for (const soldier of playerSoldiers) {
                soldier.userData.behaviourState = 'follow';
                soldier.userData.battleTarget = null;
            }
            
            for (const soldier of bot.soldiers) {
                soldier.userData.behaviourState = 'follow';
                soldier.userData.battleTarget = null;
            }
            
            // Remover marcador de batalha
            for (let i = battleMarkers.length - 1; i >= 0; i--) {
                const marker = battleMarkers[i];
                if (marker.userData.player === player && marker.userData.bot === bot) {
                    scene.remove(marker);
                    battleMarkers.splice(i, 1);
                }
            }
            
            // Esconder interface de combate
            document.getElementById('battleInfo').style.display = 'none';
            document.getElementById('formationButtons').style.display = 'none';
        }
        
        function startBattleBetweenBots(bot1, bot2) {
            // Definir estado de batalha
            bot1.isInBattle = true;
            bot1.battleWith = bot2;
            
            bot2.isInBattle = true;
            bot2.battleWith = bot1;
            
            // Atualizar estado de combate dos soldados
            for (const soldier of bot1.soldiers) {
                soldier.userData.behaviourState = 'battle';
            }
            
            for (const soldier of bot2.soldiers) {
                soldier.userData.behaviourState = 'battle';
            }
            
            // Criar marcador de batalha
            const battlePos = new THREE.Vector3().addVectors(bot1.mesh.position, bot2.mesh.position).multiplyScalar(0.5);
            const battleMarker = createBattleMarker();
            battleMarker.position.copy(battlePos);
            battleMarker.userData.bot1 = bot1;
            battleMarker.userData.bot2 = bot2;
            
            scene.add(battleMarker);
            battleMarkers.push(battleMarker);
        }
        
        function endBattleBetweenBots(bot1, bot2) {
            // Remover estado de batalha
            bot1.isInBattle = false;
            bot1.battleWith = null;
            
            bot2.isInBattle = false;
            bot2.battleWith = null;
            
            // Atualizar estado de combate dos soldados
            for (const soldier of bot1.soldiers) {
                soldier.userData.behaviourState = 'follow';
                soldier.userData.battleTarget = null;
            }
            
            for (const soldier of bot2.soldiers) {
                soldier.userData.behaviourState = 'follow';
                soldier.userData.battleTarget = null;
            }
            
            // Remover marcador de batalha
            for (let i = battleMarkers.length - 1; i >= 0; i--) {
                const marker = battleMarkers[i];
                if ((marker.userData.bot1 === bot1 && marker.userData.bot2 === bot2) ||
                    (marker.userData.bot1 === bot2 && marker.userData.bot2 === bot1)) {
                    scene.remove(marker);
                    battleMarkers.splice(i, 1);
                }
            }
        }
        
        function updateBattleMarkers(delta) {
            for (const marker of battleMarkers) {
                // Atualizar posi√ß√£o do marcador para estar entre os combatentes
                if (marker.userData.player && marker.userData.bot) {
                    // Batalha player vs bot
                    const battlePos = new THREE.Vector3().addVectors(
                        marker.userData.player.position, 
                        marker.userData.bot.mesh.position
                    ).multiplyScalar(0.5);
                    marker.position.copy(battlePos);
                } else if (marker.userData.bot1 && marker.userData.bot2) {
                    // Batalha bot vs bot
                    const battlePos = new THREE.Vector3().addVectors(
                        marker.userData.bot1.mesh.position, 
                        marker.userData.bot2.mesh.position
                    ).multiplyScalar(0.5);
                    marker.position.copy(battlePos);
                }
                
                // Anima√ß√£o
                marker.userData.swordMesh.rotation.y += marker.userData.rotationSpeed;
                
                // Anima√ß√£o de pulso
                marker.userData.pulse += marker.userData.pulseSpeed;
                const pulseFactor = Math.sin(marker.userData.pulse) * marker.userData.pulseAmount;
                marker.userData.swordMesh.position.y = marker.userData.originalY + pulseFactor;
                
                // Animar c√≠rculo
                marker.userData.circleMesh.material.opacity = 0.2 + Math.abs(Math.sin(marker.userData.pulse)) * 0.3;
            }
        }
        
        // Atualizar soldados
        function updateSoldiers(delta) {
            const DEADZONE = 0.1; // Zona morta para evitar tremores
            
            // Atualizar soldados do jogador
            for (let i = 0; i < playerSoldiers.length; i++) {
                const soldier = playerSoldiers[i];
                
                // Atualizar cooldown de ataque
                if (soldier.userData.attackCooldown > 0) {
                    soldier.userData.attackCooldown -= delta;
                }
                
                // Atualizar anima√ß√£o de ataque
                updateAttackAnimation(soldier, delta);
                
                // Definir comportamento baseado no estado
                switch (soldier.userData.behaviourState) {
                    case 'follow':
                        // Seguir o jogador em forma√ß√£o
                        const formationPos = getFormationPosition(i, playerSoldiers.length, player.position);
                        soldier.userData.targetPosition = formationPos;
                        
                        // Movimento natural em dire√ß√£o √† posi√ß√£o alvo
                        const followDistance = soldier.position.distanceTo(formationPos);
                        if (followDistance > DEADZONE) {
                            const followDirection = new THREE.Vector3().subVectors(formationPos, soldier.position).normalize();
                            const followSpeed = Math.min(0.3, followDistance * 0.2);
                            
                            soldier.position.x += followDirection.x * followSpeed;
                            soldier.position.z += followDirection.z * followSpeed;
                            
                            // Orientar o soldado para a dire√ß√£o do movimento
                            soldier.lookAt(new THREE.Vector3(
                                soldier.position.x + followDirection.x,
                                soldier.position.y,
                                soldier.position.z + followDirection.z
                            ));
                        }
                        break;
                        
                    case 'battle':
                        // Comportamento em batalha
                        let battleTarget = soldier.userData.battleTarget;
                        let nearestEnemy = null;
                        let shortestDistance = Infinity;
                        
                        // Se o jogador est√° em batalha, encontrar inimigos do oponente
                        if (player.userData.isInBattle && player.userData.battleWith) {
                            const enemySoldiers = player.userData.battleWith.soldiers;
                            
                            // Verificar se o alvo atual ainda existe
                            if (battleTarget && !enemySoldiers.includes(battleTarget)) {
                                battleTarget = null;
                                soldier.userData.battleTarget = null;
                            }
                            
                            if (!battleTarget) {
                                // Encontrar novo alvo
                                for (const enemySoldier of enemySoldiers) {
                                    const dist = soldier.position.distanceTo(enemySoldier.position);
                                    
                                    if (soldier.userData.type === 'warrior' || soldier.userData.type === 'giant') {
                                        // Guerreiros e gigantes atacam a curta dist√¢ncia
                                        const attackRange = soldier.userData.type === 'giant' ? 2 : 1.5;
                                        if (dist < 10 && dist < shortestDistance) {
                                            nearestEnemy = enemySoldier;
                                            shortestDistance = dist;
                                        }
                                    } else {
                                        // Arqueiros e magos atacam a longa dist√¢ncia
                                        if (dist < soldier.userData.range * 1.5 && dist < shortestDistance) {
                                            nearestEnemy = enemySoldier;
                                            shortestDistance = dist;
                                        }
                                    }
                                }
                                
                                if (nearestEnemy) {
                                    soldier.userData.battleTarget = nearestEnemy;
                                    battleTarget = nearestEnemy;
                                }
                            }
                            
                            // Comportamento baseado no tipo de soldado
                            if (battleTarget) {
                                if (soldier.userData.type === 'warrior' || soldier.userData.type === 'giant') {
                                    // Guerreiros e gigantes se aproximam para lutar corpo a corpo
                                    const attackRange = soldier.userData.type === 'giant' ? 2 : 1.5;
                                    const dist = soldier.position.distanceTo(battleTarget.position);
                                    
                                    if (dist > attackRange) {
                                        // Aproximar-se do alvo
                                        const direction = new THREE.Vector3().subVectors(battleTarget.position, soldier.position).normalize();
                                        soldier.position.x += direction.x * 0.3;
                                        soldier.position.z += direction.z * 0.3;
                                        
                                        // Orientar para o alvo
                                        soldier.lookAt(battleTarget.position);
                                    } else {
                                        // Atacar quando pr√≥ximo o suficiente
                                        soldier.lookAt(battleTarget.position);
                                        
                                        if (soldier.userData.attackCooldown <= 0 && !soldier.userData.isAttacking) {
                                            soldier.userData.isAttacking = true;
                                            soldier.userData.attackTime = 0;
                                            soldier.userData.attackCooldown = 1 / soldier.userData.attackSpeed;
                                            
                                            // Dano corpo a corpo ap√≥s a anima√ß√£o de ataque
                                            setTimeout(() => {
                                                if (!battleTarget.userData) return; // Verifica se o inimigo ainda existe
                                                
                                                battleTarget.userData.health -= soldier.userData.damage;
                                                
                                                // Atualizar barra de vida
                                                const healthPercentage = battleTarget.userData.health / battleTarget.userData.maxHealth;
                                                battleTarget.userData.healthBar.scale.x = Math.max(0, healthPercentage);
                                                
                                                if (battleTarget.userData.health <= 0) {
                                                    // Soldado inimigo morreu
                                                    scene.remove(battleTarget);
                                                    const botIndex = bots.findIndex(b => b.soldiers.includes(battleTarget));
                                                    if (botIndex !== -1) {
                                                        const soldierIndex = bots[botIndex].soldiers.indexOf(battleTarget);
                                                        if (soldierIndex !== -1) {
                                                            bots[botIndex].soldiers.splice(soldierIndex, 1);
                                                        }
                                                    }
                                                    playerScore += 10;
                                                    
                                                    // Limpar refer√™ncia ao inimigo morto
                                                    soldier.userData.battleTarget = null;
                                                }
                                            }, soldier.userData.type === 'giant' ? 400 : 250);
                                        }
                                    }
                                } else {
                                    // Arqueiros e magos mant√™m dist√¢ncia e atacam de longe
                                    const optimalRange = soldier.userData.range * 0.7; // 70% do alcance m√°ximo
                                    const dist = soldier.position.distanceTo(battleTarget.position);
                                    
                                    if (dist < optimalRange * 0.8) {
                                        // Muito perto, afastar-se
                                        const direction = new THREE.Vector3().subVectors(soldier.position, battleTarget.position).normalize();
                                        soldier.position.x += direction.x * 0.2;
                                        soldier.position.z += direction.z * 0.2;
                                    } else if (dist > optimalRange * 1.2) {
                                        // Muito longe, aproximar-se
                                        const direction = new THREE.Vector3().subVectors(battleTarget.position, soldier.position).normalize();
                                        soldier.position.x += direction.x * 0.2;
                                        soldier.position.z += direction.z * 0.2;
                                    }
                                    
                                    // Orientar para o alvo
                                    soldier.lookAt(battleTarget.position);
                                    
                                    // Atacar se em alcance
                                    if (dist < soldier.userData.range && soldier.userData.attackCooldown <= 0 && !soldier.userData.isAttacking) {
                                        soldier.userData.isAttacking = true;
                                        soldier.userData.attackTime = 0;
                                        soldier.userData.attackCooldown = 1 / soldier.userData.attackSpeed;
                                        
                                        if (soldier.userData.type === 'archer') {
                                            // Disparar flecha
                                            const arrowStartPos = new THREE.Vector3(
                                                soldier.position.x,
                                                soldier.position.y + 1,
                                                soldier.position.z
                                            );
                                            
                                            const direction = new THREE.Vector3().subVectors(
                                                new THREE.Vector3(battleTarget.position.x, battleTarget.position.y + 1, battleTarget.position.z),
                                                arrowStartPos
                                            );
                                            
                                            createArrow(arrowStartPos, direction, soldier);
                                        } else if (soldier.userData.type === 'mage') {
                                            // Lan√ßar bola m√°gica
                                            const ballStartPos = new THREE.Vector3(
                                                soldier.position.x,
                                                soldier.position.y + 1,
                                                soldier.position.z
                                            );
                                            
                                            const direction = new THREE.Vector3().subVectors(
                                                new THREE.Vector3(battleTarget.position.x, battleTarget.position.y + 1, battleTarget.position.z),
                                                ballStartPos
                                            );
                                            
                                            createMagicBall(ballStartPos, direction, soldier);
                                        }
                                    }
                                }
                            } else {
                                // Sem alvo, mover para forma√ß√£o de batalha
                                const battleDirection = new THREE.Vector3().subVectors(
                                    player.userData.battleWith.mesh.position,
                                    player.position
                                ).normalize();
                                
                                const formationPos = getFormationPosition(i, playerSoldiers.length, player.position, battleDirection);
                                const distance = soldier.position.distanceTo(formationPos);
                                
                                if (distance > DEADZONE) {
                                    const direction = new THREE.Vector3().subVectors(formationPos, soldier.position).normalize();
                                    const speed = Math.min(0.3, distance * 0.2);
                                    
                                    soldier.position.x += direction.x * speed;
                                    soldier.position.z += direction.z * speed;
                                    
                                    // Orientar o soldado
                                    soldier.lookAt(new THREE.Vector3(
                                        soldier.position.x + direction.x,
                                        soldier.position.y,
                                        soldier.position.z + direction.z
                                    ));
                                } else {
                                    // Em posi√ß√£o, olhar para o inimigo
                                    soldier.lookAt(player.userData.battleWith.mesh.position);
                                }
                            }
                        }
                        break;
                        
                    case 'retreat':
                        // Comportamento de retirada (implementa√ß√£o futura)
                        soldier.userData.behaviourState = 'follow';
                        break;
                }
            }
            
            // Atualizar soldados dos bots
            for (const bot of bots) {
                for (let i = 0; i < bot.soldiers.length; i++) {
                    const soldier = bot.soldiers[i];
                    
                    // Atualizar cooldown de ataque
                    if (soldier.userData.attackCooldown > 0) {
                        soldier.userData.attackCooldown -= delta;
                    }
                    
                    // Atualizar anima√ß√£o de ataque
                    updateAttackAnimation(soldier, delta);
                    
                    // Definir comportamento baseado no estado
                    switch (soldier.userData.behaviourState) {
                        case 'follow':
                            // Seguir o bot em forma√ß√£o
                            const angle = (i / bot.soldiers.length) * Math.PI * 2;
                            const radius = 3 + Math.random() * 0.5; // Variar um pouco o raio para movimento mais natural
                            const formationPos = new THREE.Vector3(
                                bot.mesh.position.x + Math.cos(angle) * radius,
                                0,
                                bot.mesh.position.z + Math.sin(angle) * radius
                            );
                            
                            const followDistance = soldier.position.distanceTo(formationPos);
                            if (followDistance > DEADZONE) {
                                const followDirection = new THREE.Vector3().subVectors(formationPos, soldier.position).normalize();
                                const followSpeed = Math.min(0.3, followDistance * 0.2);
                                
                                soldier.position.x += followDirection.x * followSpeed;
                                soldier.position.z += followDirection.z * followSpeed;
                                
                                // Orientar o soldado
                                soldier.lookAt(new THREE.Vector3(
                                    soldier.position.x + followDirection.x,
                                    soldier.position.y,
                                    soldier.position.z + followDirection.z
                                ));
                            }
                            break;
                            
                        case 'battle':
                            // Comportamento em batalha
                            let battleTarget = soldier.userData.battleTarget;
                            let nearestEnemy = null;
                            let shortestDistance = Infinity;
                            
                            // Definir o array de soldados inimigos
                            let enemySoldiers = [];
                            if (bot.battleWith === player) {
                                enemySoldiers = playerSoldiers;
                            } else if (bot.battleWith) {
                                enemySoldiers = bot.battleWith.soldiers;
                            }
                            
                            // Verificar se o alvo atual ainda existe
                            if (battleTarget && !enemySoldiers.includes(battleTarget)) {
                                battleTarget = null;
                                soldier.userData.battleTarget = null;
                            }
                            
                            if (!battleTarget && enemySoldiers.length > 0) {
                                // Encontrar novo alvo
                                for (const enemySoldier of enemySoldiers) {
                                    const dist = soldier.position.distanceTo(enemySoldier.position);
                                    
                                    if (soldier.userData.type === 'warrior' || soldier.userData.type === 'giant') {
                                        // Guerreiros e gigantes atacam a curta dist√¢ncia
                                        const attackRange = soldier.userData.type === 'giant' ? 2 : 1.5;
                                        if (dist < 10 && dist < shortestDistance) {
                                            nearestEnemy = enemySoldier;
                                            shortestDistance = dist;
                                        }
                                    } else {
                                        // Arqueiros e magos atacam a longa dist√¢ncia
                                        if (dist < soldier.userData.range * 1.5 && dist < shortestDistance) {
                                            nearestEnemy = enemySoldier;
                                            shortestDistance = dist;
                                        }
                                    }
                                }
                                
                                if (nearestEnemy) {
                                    soldier.userData.battleTarget = nearestEnemy;
                                    battleTarget = nearestEnemy;
                                }
                            }
                            
                            // Comportamento baseado no tipo de soldado
                            if (battleTarget) {
                                if (soldier.userData.type === 'warrior' || soldier.userData.type === 'giant') {
                                    // Guerreiros e gigantes se aproximam para lutar corpo a corpo
                                    const attackRange = soldier.userData.type === 'giant' ? 2 : 1.5;
                                    const dist = soldier.position.distanceTo(battleTarget.position);
                                    
                                    if (dist > attackRange) {
                                        // Aproximar-se do alvo
                                        const direction = new THREE.Vector3().subVectors(battleTarget.position, soldier.position).normalize();
                                        soldier.position.x += direction.x * 0.3;
                                        soldier.position.z += direction.z * 0.3;
                                        
                                        // Orientar para o alvo
                                        soldier.lookAt(battleTarget.position);
                                    } else {
                                        // Atacar quando pr√≥ximo o suficiente
                                        soldier.lookAt(battleTarget.position);
                                        
                                        if (soldier.userData.attackCooldown <= 0 && !soldier.userData.isAttacking) {
                                            soldier.userData.isAttacking = true;
                                            soldier.userData.attackTime = 0;
                                            soldier.userData.attackCooldown = 1 / soldier.userData.attackSpeed;
                                            
                                            // Dano corpo a corpo ap√≥s a anima√ß√£o de ataque
                                            setTimeout(() => {
                                                if (!battleTarget.userData) return; // Verifica se o inimigo ainda existe
                                                
                                                battleTarget.userData.health -= soldier.userData.damage;
                                                
                                                // Atualizar barra de vida
                                                const healthPercentage = battleTarget.userData.health / battleTarget.userData.maxHealth;
                                                battleTarget.userData.healthBar.scale.x = Math.max(0, healthPercentage);
                                                
                                                if (battleTarget.userData.health <= 0) {
                                                    // Soldado inimigo morreu
                                                    scene.remove(battleTarget);
                                                    
                                                    // Verificar se √© soldado do jogador
                                                    const playerSoldierIndex = playerSoldiers.indexOf(battleTarget);
                                                    if (playerSoldierIndex !== -1) {
                                                        playerSoldiers.splice(playerSoldierIndex, 1);
                                                        bot.score += 10;
                                                    } else {
                                                        // Ou de outro bot
                                                        for (const otherBot of bots) {
                                                            const soldierIndex = otherBot.soldiers.indexOf(battleTarget);
                                                            if (soldierIndex !== -1) {
                                                                otherBot.soldiers.splice(soldierIndex, 1);
                                                                bot.score += 10;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    
                                                    // Limpar refer√™ncia ao inimigo morto
                                                    soldier.userData.battleTarget = null;
                                                }
                                            }, soldier.userData.type === 'giant' ? 400 : 250);
                                        }
                                    }
                                } else {
                                    // Arqueiros e magos mant√™m dist√¢ncia e atacam de longe
                                    const optimalRange = soldier.userData.range * 0.7; // 70% do alcance m√°ximo
                                    const dist = soldier.position.distanceTo(battleTarget.position);
                                    
                                    if (dist < optimalRange * 0.8) {
                                        // Muito perto, afastar-se
                                        const direction = new THREE.Vector3().subVectors(soldier.position, battleTarget.position).normalize();
                                        soldier.position.x += direction.x * 0.2;
                                        soldier.position.z += direction.z * 0.2;
                                    } else if (dist > optimalRange * 1.2) {
                                        // Muito longe, aproximar-se
                                        const direction = new THREE.Vector3().subVectors(battleTarget.position, soldier.position).normalize();
                                        soldier.position.x += direction.x * 0.2;
                                        soldier.position.z += direction.z * 0.2;
                                    }
                                    
                                    // Orientar para o alvo
                                    soldier.lookAt(battleTarget.position);
                                    
                                    // Atacar se em alcance
                                    if (dist < soldier.userData.range && soldier.userData.attackCooldown <= 0 && !soldier.userData.isAttacking) {
                                        soldier.userData.isAttacking = true;
                                        soldier.userData.attackTime = 0;
                                        soldier.userData.attackCooldown = 1 / soldier.userData.attackSpeed;
                                        
                                        if (soldier.userData.type === 'archer') {
                                            // Disparar flecha
                                            const arrowStartPos = new THREE.Vector3(
                                                soldier.position.x,
                                                soldier.position.y + 1,
                                                soldier.position.z
                                            );
                                            
                                            const direction = new THREE.Vector3().subVectors(
                                                new THREE.Vector3(battleTarget.position.x, battleTarget.position.y + 1, battleTarget.position.z),
                                                arrowStartPos
                                            );
                                            
                                            createArrow(arrowStartPos, direction, soldier);
                                        } else if (soldier.userData.type === 'mage') {
                                            // Lan√ßar bola m√°gica
                                            const ballStartPos = new THREE.Vector3(
                                                soldier.position.x,
                                                soldier.position.y + 1,
                                                soldier.position.z
                                            );
                                            
                                            const direction = new THREE.Vector3().subVectors(
                                                new THREE.Vector3(battleTarget.position.x, battleTarget.position.y + 1, battleTarget.position.z),
                                                ballStartPos
                                            );
                                            
                                            createMagicBall(ballStartPos, direction, soldier);
                                        }
                                    }
                                }
                            } else {
                                // Sem alvo, mover para forma√ß√£o de batalha
                                let targetPos;
                                let battleDirection;
                                
                                if (bot.battleWith === player) {
                                    battleDirection = new THREE.Vector3().subVectors(
                                        player.position,
                                        bot.mesh.position
                                    ).normalize();
                                } else if (bot.battleWith) {
                                    battleDirection = new THREE.Vector3().subVectors(
                                        bot.battleWith.mesh.position,
                                        bot.mesh.position
                                    ).normalize();
                                } else {
                                    battleDirection = new THREE.Vector3(0, 0, 1);
                                }
                                
                                // Posi√ß√£o em forma√ß√£o de batalha
                                const angle = (i / bot.soldiers.length - 0.5) * Math.PI;
                                const radius = 4 + Math.cos(angle) * 2;
                                const offsetX = Math.cos(angle) * 3;
                                const offsetZ = Math.sin(angle) * 3;
                                
                                // Rotacionar o offset para alinhar com a dire√ß√£o da batalha
                                const battleAngle = Math.atan2(battleDirection.z, battleDirection.x);
                                const rotatedOffsetX = offsetX * Math.cos(battleAngle) - offsetZ * Math.sin(battleAngle);
                                const rotatedOffsetZ = offsetX * Math.sin(battleAngle) + offsetZ * Math.cos(battleAngle);
                                
                                targetPos = new THREE.Vector3(
                                    bot.mesh.position.x + battleDirection.x * radius + rotatedOffsetX,
                                    0,
                                    bot.mesh.position.z + battleDirection.z * radius + rotatedOffsetZ
                                );
                                
                                const distance = soldier.position.distanceTo(targetPos);
                                
                                if (distance > DEADZONE) {
                                    const direction = new THREE.Vector3().subVectors(targetPos, soldier.position).normalize();
                                    const speed = Math.min(0.3, distance * 0.2);
                                    
                                    soldier.position.x += direction.x * speed;
                                    soldier.position.z += direction.z * speed;
                                    
                                    // Orientar o soldado
                                    soldier.lookAt(new THREE.Vector3(
                                        soldier.position.x + direction.x,
                                        soldier.position.y,
                                        soldier.position.z + direction.z
                                    ));
                                } else {
                                    // Em posi√ß√£o, olhar para o inimigo
                                    if (bot.battleWith === player) {
                                        soldier.lookAt(player.position);
                                    } else if (bot.battleWith) {
                                        soldier.lookAt(bot.battleWith.mesh.position);
                                    }
                                }
                            }
                            break;
                            
                        case 'retreat':
                            // Comportamento de retirada (implementa√ß√£o futura)
                            soldier.userData.behaviourState = 'follow';
                            break;
                    }
                }
            }
        }
        
        // Atualizar proj√©teis
        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                
                // Mover proj√©til
                projectile.mesh.position.add(
                    projectile.direction.clone().multiplyScalar(projectile.speed)
                );
                
                // Efeitos especiais para diferentes tipos de proj√©teis
                if (projectile.type === 'magic') {
                    // Animar bola m√°gica
                    projectile.mesh.rotation.x += 0.05;
                    projectile.mesh.rotation.y += 0.05;
                    
                    // Pulsar brilho
                    const scale = 1 + Math.sin(Date.now() * 0.01) * 0.2;
                    projectile.glow.scale.set(scale, scale, scale);
                    
                    // Girar an√©is
                    projectile.ring1.rotation.x += 0.1;
                    projectile.ring2.rotation.y += 0.1;
                    
                    // Atualizar rastro
                    for (let j = projectile.trailPositions.length / 3 - 1; j > 0; j--) {
                        projectile.trailPositions[j * 3] = projectile.trailPositions[(j - 1) * 3];
                        projectile.trailPositions[j * 3 + 1] = projectile.trailPositions[(j - 1) * 3 + 1];
                        projectile.trailPositions[j * 3 + 2] = projectile.trailPositions[(j - 1) * 3 + 2];
                    }
                    
                    // Nova posi√ß√£o para in√≠cio do rastro
                    projectile.trailPositions[0] = projectile.mesh.position.x;
                    projectile.trailPositions[1] = projectile.mesh.position.y;
                    projectile.trailPositions[2] = projectile.mesh.position.z;
                    
                    projectile.trail.geometry.attributes.position.needsUpdate = true;
                }
                
                // Reduzir tempo de vida
                projectile.lifespan--;
                
                // Verificar colis√µes
                let hit = false;
                
                // Quem s√£o os inimigos deste proj√©til?
                const enemies = [];
                if (playerSoldiers.includes(projectile.owner)) {
                    // Proj√©til do jogador, inimigos s√£o soldados dos bots em batalha
                    if (player.userData.isInBattle && player.userData.battleWith) {
                        enemies.push(...player.userData.battleWith.soldiers);
                    }
                } else {
                    // Proj√©til de bot, inimigos dependem de quem est√° em batalha
                    let ownerBot = null;
                    for (const bot of bots) {
                        if (bot.soldiers.includes(projectile.owner)) {
                            ownerBot = bot;
                            break;
                        }
                    }
                    
                    if (ownerBot && ownerBot.battleWith === player) {
                        enemies.push(...playerSoldiers);
                    } else if (ownerBot && ownerBot.battleWith) {
                        enemies.push(...ownerBot.battleWith.soldiers);
                    }
                }
                
                // Verificar colis√£o com inimigos
                for (const enemy of enemies) {
                    if (projectile.mesh.position.distanceTo(
                        new THREE.Vector3(enemy.position.x, enemy.position.y + 1, enemy.position.z)
                    ) < 0.5) {
                        // Acertou inimigo
                        enemy.userData.health -= projectile.damage;
                        
                        // Atualizar barra de vida
                        const healthPercentage = enemy.userData.health / enemy.userData.maxHealth;
                        enemy.userData.healthBar.scale.x = Math.max(0, healthPercentage);
                        
                        if (enemy.userData.health <= 0) {
                            // Soldado inimigo morreu
                            scene.remove(enemy);
                            
                            // Verificar a quem o soldado pertence e remov√™-lo
                            const playerSoldierIndex = playerSoldiers.indexOf(enemy);
                            if (playerSoldierIndex !== -1) {
                                playerSoldiers.splice(playerSoldierIndex, 1);
                                
                                // Dar pontos ao bot dono do proj√©til
                                for (const bot of bots) {
                                    if (bot.soldiers.includes(projectile.owner)) {
                                        bot.score += 10;
                                        break;
                                    }
                                }
                            } else {
                                // Checar cada bot
                                for (const bot of bots) {
                                    const soldierIndex = bot.soldiers.indexOf(enemy);
                                    if (soldierIndex !== -1) {
                                        bot.soldiers.splice(soldierIndex, 1);
                                        
                                        // Dar pontos ao dono do proj√©til
                                        if (playerSoldiers.includes(projectile.owner)) {
                                            playerScore += 10;
                                        } else {
                                            // Dar pontos ao bot dono do proj√©til
                                            for (const ownerBot of bots) {
                                                if (ownerBot.soldiers.includes(projectile.owner)) {
                                                    ownerBot.score += 10;
                                                    break;
                                                }
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        
                        hit = true;
                        break;
                    }
                }
                
                // Verificar colis√µes com objetos do ambiente
                for (const tree of trees) {
                    if (projectile.mesh.position.distanceTo(tree.position) < 2.5) {
                        hit = true;
                        break;
                    }
                }
                
                for (const rock of rocks) {
                    if (projectile.mesh.position.distanceTo(rock.position) < 1.5) {
                        hit = true;
                        break;
                    }
                }
                
                // Remover proj√©til se atingiu algo ou acabou o tempo de vida
                if (hit || projectile.lifespan <= 0) {
                    scene.remove(projectile.mesh);
                    if (projectile.trail) scene.remove(projectile.trail);
                    projectiles.splice(i, 1);
                }
            }
        }
        
        // Atualizar vilas
        function updateVillages(delta) {
            for (const village of villages) {
                if (!village.userData.available) {
                    village.userData.cooldown -= delta;
                    
                    // Atualizar indicador de disponibilidade
                    const progress = 1 - (village.userData.cooldown / village.userData.maxCooldown);
                    village.userData.indicator.material.color.setRGB(
                        1 - progress,  // vermelho -> 0
                        progress,      // verde -> 1
                        0
                    );
                    
                    if (village.userData.cooldown <= 0) {
                        village.userData.available = true;
                        village.userData.indicator.material.color.set(0x00FF00);
                        
                        // Mostrar bandeira quando a vila est√° dispon√≠vel
                        village.userData.flag.visible = true;
                        village.userData.flagVisibility = true;
                    }
                }
                
                // Animar bandeira suavemente
                if (village.userData.flagVisibility) {
                    const time = Date.now() * 0.001;
                    village.userData.flag.position.y = 2.7 + Math.sin(time * 2) * 0.05;
                }
            }
        }
        
        // Atualizar bots
        function updateBots() {
            for (const bot of bots) {
                // Movimento dos bots
                const moveSpeed = 0.2 * (bot.powerups.speed.active ? bot.powerups.speed.multiplier : 1.0);
                
                if (bot.isInBattle) {
                    // Se est√° em batalha, manter posi√ß√£o estrat√©gica
                    const targetPos = bot.mesh.position.clone();
                    if (bot.battleWith === player) {
                        const direction = new THREE.Vector3().subVectors(player.position, bot.mesh.position).normalize();
                        targetPos.add(direction.multiplyScalar(8)); // Manter dist√¢ncia ideal
                    } else {
                        const direction = new THREE.Vector3().subVectors(bot.battleWith.mesh.position, bot.mesh.position).normalize();
                        targetPos.add(direction.multiplyScalar(8)); // Manter dist√¢ncia ideal
                    }
                    
                    const moveDirection = new THREE.Vector3().subVectors(targetPos, bot.mesh.position).normalize();
                    
                    // Movimento muito lento ou nenhum movimento durante a batalha
                    bot.mesh.position.x += moveDirection.x * moveSpeed * 0.1;
                    bot.mesh.position.z += moveDirection.z * moveSpeed * 0.1;
                    
                    // Orientar o bot para a dire√ß√£o do oponente
                    if (bot.battleWith === player) {
                        bot.mesh.lookAt(player.position);
                    } else {
                        bot.mesh.lookAt(bot.battleWith.mesh.position);
                    }
                } else {
                    // Se n√£o est√° em batalha
                    if (bot.soldiers.length < MAX_SOLDIERS) {
                        // Procurar vila mais pr√≥xima para recrutar
                        let nearestVillage = null;
                        let shortestDistance = Infinity;
                        
                        for (const village of villages) {
                            if (village.userData.available) {
                                const distance = bot.mesh.position.distanceTo(village.position);
                                if (distance < shortestDistance) {
                                    nearestVillage = village;
                                    shortestDistance = distance;
                                }
                            }
                        }
                        
                        if (nearestVillage && shortestDistance < 50) {
                            // Ir em dire√ß√£o √† vila
                            bot.target = nearestVillage.position.clone();
                        } else if (bot.mesh.position.distanceTo(bot.target) < 5 || Math.random() < 0.01) {
                            // Escolher novo destino aleat√≥rio
                            bot.target.set(
                                Math.random() * 180 - 90,
                                0,
                                Math.random() * 180 - 90
                            );
                        }
                    } 
                    else if (Math.random() < 0.01) {
                        // Buscar oponentes quando j√° tem soldados suficientes
                        // Encontrar jogador ou bot mais pr√≥ximo
                        let nearestOpponent = null;
                        let shortestDistance = Infinity;
                        
                        // Verificar dist√¢ncia at√© o jogador
                        const distanceToPlayer = bot.mesh.position.distanceTo(player.position);
                        if (distanceToPlayer < shortestDistance && playerSoldiers.length > 0) {
                            nearestOpponent = player.position.clone();
                            shortestDistance = distanceToPlayer;
                        }
                        
                        // Verificar dist√¢ncia at√© outros bots
                        for (const otherBot of bots) {
                            if (otherBot !== bot && otherBot.soldiers.length > 0) {
                                const distance = bot.mesh.position.distanceTo(otherBot.mesh.position);
                                if (distance < shortestDistance) {
                                    nearestOpponent = otherBot.mesh.position.clone();
                                    shortestDistance = distance;
                                }
                            }
                        }
                        
                        if (nearestOpponent && shortestDistance < 50) {
                            // Ir em dire√ß√£o ao oponente
                            bot.target = nearestOpponent;
                        } else if (bot.mesh.position.distanceTo(bot.target) < 5 || Math.random() < 0.01) {
                            // Escolher novo destino aleat√≥rio
                            bot.target.set(
                                Math.random() * 180 - 90,
                                0,
                                Math.random() * 180 - 90
                            );
                        }
                    }
                    else if (bot.mesh.position.distanceTo(bot.target) < 5 || Math.random() < 0.01) {
                        // Escolher novo destino aleat√≥rio
                        bot.target.set(
                            Math.random() * 180 - 90,
                            0,
                            Math.random() * 180 - 90
                        );
                    }
                    
                    // Mover em dire√ß√£o ao destino
                    const direction = new THREE.Vector3().subVectors(bot.target, bot.mesh.position).normalize();
                    bot.mesh.position.x += direction.x * moveSpeed;
                    bot.mesh.position.z += direction.z * moveSpeed;
                    
                    // Orientar o bot para a dire√ß√£o do movimento
                    if (direction.length() > 0.01) {
                        bot.mesh.lookAt(new THREE.Vector3(
                            bot.mesh.position.x + direction.x,
                            bot.mesh.position.y,
                            bot.mesh.position.z + direction.z
                        ));
                    }
                }
                
                // Animar asas do pinguim
                if (!bot.isInBattle || bot.mesh.position.distanceTo(bot.target) > 1) {
                    bot.mesh.userData.isWalking = true;
                    bot.mesh.userData.walkTime += 0.1;
                    const wingAngle = Math.sin(bot.mesh.userData.walkTime * 3) * 0.3;
                    bot.mesh.userData.leftWing.rotation.x = wingAngle;
                    bot.mesh.userData.rightWing.rotation.x = wingAngle;
                } else {
                    bot.mesh.userData.isWalking = false;
                    bot.mesh.userData.leftWing.rotation.x = 0;
                    bot.mesh.userData.rightWing.rotation.x = 0;
                }
                
                // Limitar posi√ß√£o dentro do mapa
                bot.mesh.position.x = Math.max(-95, Math.min(95, bot.mesh.position.x));
                bot.mesh.position.z = Math.max(-95, Math.min(95, bot.mesh.position.z));
                
                // Tentar contratar soldados das vilas
                for (const village of villages) {
                    if (bot.mesh.position.distanceTo(village.position) < 5 && village.userData.available && bot.soldiers.length < MAX_SOLDIERS) {
                        // Contratar soldado
                        let soldier;
                        switch(village.userData.type) {
                            case 'warrior':
                                soldier = createWarrior();
                                break;
                            case 'archer':
                                soldier = createArcher();
                                break;
                            case 'mage':
                                soldier = createMage();
                                break;
                            case 'giant':
                                soldier = createGiant();
                                break;
                            default:
                                soldier = createWarrior();
                        }
                        
                        if (soldier) {
                            // Posi√ß√£o inicial do soldado
                            const angle = Math.random() * Math.PI * 2;
                            const distance = 2 + Math.random();
                            soldier.position.x = bot.mesh.position.x + Math.cos(angle) * distance;
                            soldier.position.z = bot.mesh.position.z + Math.sin(angle) * distance;
                            
                            // Aplicar for√ßa baseada em power-up
                            if (bot.powerups.strength.active) {
                                soldier.userData.damage = soldier.userData.originalStrength * bot.powerups.strength.multiplier;
                            }
                            
                            // Definir forma√ß√£o e comportamento inicial
                            soldier.userData.formationIndex = bot.soldiers.length;
                            soldier.userData.behaviourState = 'follow';
                            
                            scene.add(soldier);
                            bot.soldiers.push(soldier);
                            bot.score += 5;
                            
                            village.userData.available = false;
                            village.userData.cooldown = village.userData.maxCooldown;
                            village.userData.indicator.material.color.set(0xFF0000);
                            
                            // Esconder a bandeira quando a vila n√£o est√° dispon√≠vel
                            village.userData.flag.visible = false;
                            village.userData.flagVisibility = false;
                        }
                    }
                }
                
                // Verificar power-ups
                for (let i = powerups.length - 1; i >= 0; i--) {
                    const powerup = powerups[i];
                    
                    if (bot.mesh.position.distanceTo(powerup.position) < 2) {
                        // Ativar power-up para o bot
                        if (powerup.userData.type === 'speed') {
                            bot.powerups.speed.active = true;
                            bot.powerups.speed.multiplier = 2.0;
                            bot.powerups.speed.duration = bot.powerups.speed.maxDuration;
                        } else if (powerup.userData.type === 'strength') {
                            bot.powerups.strength.active = true;
                            bot.powerups.strength.multiplier = 2.0;
                            bot.powerups.strength.duration = bot.powerups.strength.maxDuration;
                            
                            // Aplicar for√ßa extra aos soldados
                            for (const soldier of bot.soldiers) {
                                soldier.userData.damage = soldier.userData.originalStrength * bot.powerups.strength.multiplier;
                            }
                        }
                        
                        // Remover o power-up do mapa
                        scene.remove(powerup);
                        powerups.splice(i, 1);
                        
                        // Adicionar pontos
                        bot.score += 5;
                    }
                }
            }
        }
        
        // Timer do jogo
        function updateTimer() {
            if (timeRemaining > 0) {
                timeRemaining -= 1;
            } else {
                endGame();
            }
        }
        
        setInterval(updateTimer, 1000);
        
        // Fim do jogo
        function endGame() {
            gameActive = false;
            
            // Mostrar tela de fim de jogo
            const gameOverScreen = document.getElementById('gameOver');
            gameOverScreen.style.display = 'block';
            
            // Calcular pontua√ß√£o final
            document.getElementById('finalScore').textContent = `Pontua√ß√£o final: ${playerScore}`;
            
            // Calcular ranking final
            const allPlayers = [
                { name: playerName, score: playerScore },
                ...bots.map(bot => ({ name: bot.name, score: bot.score }))
            ];
            
            allPlayers.sort((a, b) => b.score - a.score);
            
            const playerRank = allPlayers.findIndex(p => p.name === playerName) + 1;
            document.getElementById('finalRank').textContent = `Classifica√ß√£o: ${playerRank}¬∫ de ${allPlayers.length}`;
        }
        
        // Reiniciar jogo
        function restartGame() {
            window.location.reload();
        }
        
        // Rel√≥gio para delta time
        const clock = new THREE.Clock();
        
        // Animar jogador
        function updatePlayerAnimation() {
            // Verificar se est√° se movendo
            const isMoving = keys.w || keys.a || keys.s || keys.d;
            
            if (isMoving && !player.userData.isWalking) {
                player.userData.isWalking = true;
            } else if (!isMoving && player.userData.isWalking) {
                player.userData.isWalking = false;
                // Resetar posi√ß√£o das asas
                player.userData.leftWing.rotation.x = 0;
                player.userData.rightWing.rotation.x = 0;
            }
            
            // Animar asas se estiver andando
            if (player.userData.isWalking) {
                player.userData.walkTime += 0.1;
                const wingAngle = Math.sin(player.userData.walkTime * 3) * 0.3;
                player.userData.leftWing.rotation.x = wingAngle;
                player.userData.rightWing.rotation.x = wingAngle;
            }
        }
        
        // Inicializa√ß√£o das coroas para todos os pinguins
        function setupLeaderCrowns() {
            createCrownForLeader(player);
            
            for (const bot of bots) {
                createCrownForLeader(bot.mesh);
            }
        }
        
        // Loop de anima√ß√£o
        function animate() {
            requestAnimationFrame(animate);
            
            // Calcular delta time
            const delta = clock.getDelta();
            
            if (gameActive) {
                // Movimento do jogador
                if (!player.userData.isInBattle) {
                    const moveSpeed = 0.3 * (playerPowerups.speed.active ? playerPowerups.speed.multiplier : 1.0);
                    if (keys.w) player.position.z -= moveSpeed;
                    if (keys.s) player.position.z += moveSpeed;
                    if (keys.a) player.position.x -= moveSpeed;
                    if (keys.d) player.position.x += moveSpeed;
                    
                    // Orientar o jogador para a dire√ß√£o do movimento
                    if (keys.w || keys.a || keys.s || keys.d) {
                        const direction = new THREE.Vector3(
                            (keys.d ? 1 : 0) - (keys.a ? 1 : 0),
                            0,
                            (keys.s ? 1 : 0) - (keys.w ? 1 : 0)
                        ).normalize();
                        
                        if (direction.length() > 0) {
                            player.lookAt(new THREE.Vector3(
                                player.position.x + direction.x,
                                player.position.y,
                                player.position.z + direction.z
                            ));
                        }
                    }
                } else {
                    // Em batalha, o jogador pode se mover muito lentamente ou ficar parado
                    const moveSpeed = 0.05 * (playerPowerups.speed.active ? playerPowerups.speed.multiplier : 1.0);
                    if (keys.w) player.position.z -= moveSpeed;
                    if (keys.s) player.position.z += moveSpeed;
                    if (keys.a) player.position.x -= moveSpeed;
                    if (keys.d) player.position.x += moveSpeed;
                    
                    // Manter o jogador olhando para o oponente
                    if (player.userData.battleWith) {
                        player.lookAt(player.userData.battleWith.mesh.position);
                    }
                }
                
                // Limitar o movimento do jogador dentro do mapa
                player.position.x = Math.max(-95, Math.min(95, player.position.x));
                player.position.z = Math.max(-95, Math.min(95, player.position.z));
                
                // Atualizar anima√ß√£o do jogador
                updatePlayerAnimation();
                
                // Atualizar posi√ß√£o da c√¢mera
                camera.position.x = player.position.x;
                camera.position.z = player.position.z + 10;
                camera.lookAt(player.position);
                
                checkVillageCollision();
                checkPowerupCollision();
                checkBattles();
                updateSoldiers(delta);
                updateVillages(delta);
                updateProjectiles();
                updateBots();
                updatePowerups(delta);
                updateBattleMarkers(delta);
                updateHUD();
            }
            
            renderer.render(scene, camera);
        }
        
        // Redimensionar janela
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        window.addEventListener('resize', onWindowResize);
        
        // Inicializar coroas de l√≠deres
        setupLeaderCrowns();
        
        // Iniciar jogo
        animate();

        // Adendo para integra√ß√£o Click Jogos: Prevenir Scroll com Teclas de Seta
        window.addEventListener('keydown', (event) => {
            const gameControlKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space']; // Adicione 'Space' ou outras teclas se necess√°rio

            if (gameControlKeys.includes(event.code)) {
                console.log(`Jogo: Impedindo a√ß√£o padr√£o para ${event.code}`);
                event.preventDefault(); // Impede a a√ß√£o padr√£o (scroll) e a propaga√ß√£o para a p√°gina pai
            }
        });

    </script>
</body>
</html>
